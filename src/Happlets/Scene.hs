-- | This module provides an 'Act', 'Scene', and 'Actor' data types, and the 'Script' function
-- type. Every 'Act' contains a current 'Scene', a 'Script' function type can alter the current
-- 'Scene' of an 'Act' by instructing 'Actor's how to behave. The 'Act' data type is a Happlet that
-- can automatically sets it's own Happlet event handlers based on the needs of the 'Actor's in the
-- current 'Scene'.
--
-- 'Actor' data types have their own internal state values which can only be modified by 'Script'
-- functions. 'Actor's have callbacks for virtual event handlers which are generated by the 'Act' in
-- response to low-level Happllet events. The 'Actor' event callbacks are slightly different from
-- that of the 'Happlet' event handlers, for example, actions for left, right, and double-click
-- mouse actions can be set for each 'Actor' are provided, unlike a 'Happlet' which does not provide
-- a double-click event handler, and which does not provide separate actions for left and right
-- clicks. 'Actor' event handlers also use callback functions of type 'Script', and __not__ of type
-- 'GUI' as a low-level Happlet would.
--
-- 'Act' data values are usually not manipulated directly, they are the @model@ type used by the
-- 'GUI' monad. 'Act's are initialized by 'newActHapplet' and initialized with a function of type
-- 'Script' which places various 'Actors' in their "first positions" (initial states) into the
-- current 'Scene' of the 'Act'. The 'Act' itself handles it's own low-level Happlet events based on
-- the event handlers in use by all 'Actor's in it's current 'Scene'.
module Happlets.Scene
  ( -- ** Acts
    Act, actWindow, newActHapplet, actLiftIO,
    -- ** Scenes
    Scene, SceneAction, newScene, sceneBracket,
    -- *** Selecting Actors in a Scene
    ActorSelect, ActorInfo(..), selectInScene,
    -- ** The Actor data type
    Actor, TypedActor, theUntypedActor, actor, actress, selfLabel,
    -- *** Actor Event Handler Accounting
    ActorEventHandlerStats, countActors, countActionDraw, countActionSelect,
    countActionKeyboard, countActionClick, countActionDoubleClick, countActionRightClick,
    countActionMouseOver, countActionMouseDrag, countActionAnimation,
    -- ** The Script function type
    Script, Projector, runScript, getViewBounds,
    -- *** Sending and Delegating Events
    actorRedraw, actorAnimate, actorKeyboard, actorClick,
    actorDoubleClick, actorRightClick, actorMouseOver, actorMouseDrag,
    -- ** Event Handlers
    OnQueue, onDraw, onSelect, onKeyboard, onAnimate,
    onClick, onDoubleClick, onRightClick, onMouseOver, onMouseDrag,
    -- *** Event Handler Types
    EventAction(..), runEventAction,
    DrawAction(..), runDrawAction, runDrawActionGUI,
    -- ** Low-Level Happlets APIs
    guiInterpretScript, guiInterpretProjector,
    actKeyboardHandler,
    actAnimationHandler,
    actClick, actRightClick, actDoubleClick,
    actMouseOver, actMouseDrag,
  ) where

import           Happlets.Initialize
import           Happlets.Model
import           Happlets.Model.Registry
import           Happlets.View
import           Happlets.Control.Animate     (CanAnimate(stepFrameEvents))
import           Happlets.Control.Mouse
                 ( CanMouse(mouseEvents), Mouse(..),
                   MouseEventPattern(MouseButton, MouseDrag, MouseAll),
                   similarMouseEvents, mouseEventDistance
                 )
import           Happlets.Control.Keyboard
                 ( CanKeyboard(keyboardEvents),
                   Keyboard(Keyboard, RawKey),
                 )
import           Happlets.Control.WindowManager

import           Control.Applicative        (Alternative(..))
import           Control.Concurrent.MVar    (newMVar, withMVar)
import           Control.Lens
                 ( Lens', lens, cloneLens, view, use, assign, modifying, (^.), (%~), (.~), (.=),
                 )
import           Control.Monad              (MonadPlus(..), join, (>=>), guard)
import           Control.Monad.Fail
import           Control.Monad.IO.Class     (MonadIO(..))
import           Control.Monad.Reader       (MonadReader(..), ReaderT(..), asks)
import           Control.Monad.Trans        (MonadTrans(..))

--import           Data.Functor.Const         (Const(..))
import           Data.IORef                 (IORef, newIORef, readIORef, writeIORef)
import qualified Data.Text                  as Strict
import           Data.Time.Clock            (UTCTime, getCurrentTime, diffUTCTime)

import           System.IO                  (hPutStrLn, stderr)

----------------------------------------------------------------------------------------------------

-- | The 'Script' function type is a procedure (a script) that defines the behavior of an 'Actor'
-- while is active in a 'Scene'. The 'Script' operates on a 'TypedActor' containing @model@ state
-- data, and so the 'Script' @model@ type will always be the same as the 'TypedActor's @model@ type.
-- 
-- The 'Script' function type is monadic and instantiates 'MonadState' so that the @model@ data
-- can be inspected and updated using the ordinary 'get', 'put', 'modify', and 'state' functions.
--
-- There are also several APIs defined below, many of which begin with the name "self", which are
-- used to alter the event handlers of the 'TypedActor' that the 'Script' is currently operating on.
--
-- 'Script' instantiates the 'CancelableAction' function, so you can evaluate 'cancel' somwhere in
-- the 'Script' to indicate that this particular event should no longer be reacted to by an 'Actor'.
newtype Script model a
  = Script{ unwrapScript :: ConsequenceT (StateT (ScriptState model) IO) a }
  deriving Functor -- NOT deriving MonadIO

data ScriptState model
  = ScriptState
    { theScriptRole        :: !(Role model) -- ^ The model currently being updated.
    , theScriptAct         :: !Act -- ^ Access to the 'Act'.
    , theScriptRoleUpdated :: !Bool -- ^ Records whether 'theScriptRole' was modified.
    }

instance Applicative (Script model) where
  pure = Script . pure
  (Script f) <*> (Script a) = Script $ f <*> a

instance Monad (Script model) where
  return = pure
  (Script a) >>= f = Script $ a >>= unwrapScript . f

instance MonadState model (Script model) where
  state f = Script $ do
    (a, widget) <- fmap f $ lift $  use $ scriptRole . roleModel
    lift $ scriptRole . roleModel .= widget
    return a

instance MonadError Strict.Text (Script model) where
  throwError = Script . throwError
  catchError (Script try) catch = Script $ catchError try $ unwrapScript . catch

instance MonadFail (Script model) where { fail = throwError . Strict.pack; }

instance Alternative (Script model) where
  empty = Script empty
  (Script a) <|> (Script b) = Script $ a <|> b

instance MonadPlus (Script model) where { mzero = empty; mplus = (<|>); }

instance Consequential (Script model) where { cancel = Script cancel; }

instance Monoid a => Semigroup (Script model a) where
  a <> b = mappend <$> (a <|> pure mempty) <*> (b <|> pure mempty)

instance Monoid a => Monoid (Script model a) where
  mempty = pure mempty
  mappend = (<>)

-- | Run a 'Script' which performs some update on the @model@.
runScript :: Script model a -> ScriptState model -> IO (Consequence a, ScriptState model)
runScript = runStateT . runConsequenceT . unwrapScript

-- | not for export
scriptIO :: IO a -> Script model a
scriptIO = Script . liftIO

-- | not for export
scriptGets :: (ScriptState model -> a) -> Script model a
scriptGets = Script . lift . gets

scriptModify :: (ScriptState model -> ScriptState model) -> Script model ()
scriptModify = Script . lift . modify

scriptGetsRole :: (Role model -> a) -> Script model a
scriptGetsRole = scriptGets . (. theScriptRole)

scriptGetsAct :: (Act -> a) -> Script model a
scriptGetsAct = scriptGets . (. theScriptAct)

scriptGetsScene :: (Scene -> a) -> Script model a
scriptGetsScene = scriptGetsAct . (. theActCurrentScene)

-- | Access to the @model@ that is being updated by this 'Script'.
scriptRole :: Lens' (ScriptState model) (Role model)
scriptRole = lens theScriptRole $ \ a b -> a{ theScriptRole = b }

-- | Access to the 'Acr' in which this script is being recited.
scriptAct :: Lens' (ScriptState model) Act
scriptAct = lens theScriptAct $ \ a b -> a{ theScriptAct = b }

-- | Access to the 'Scene' in which this script is being recited.
scriptScene :: Lens' (ScriptState model) Scene
scriptScene = scriptAct . actCurrentScene

-- | A 'TypedActor' allows you to assign an arbitrary text string to it called a "label". This text
-- string can be used for any reason at all, it need not be unique. It is usually used to provide
-- some kind of information to end users about the 'Actor', like what it is and where it originated,
-- or perhaps even the code that constructed it.
--
-- Provide a function for modifying the description, the modified description is returned. Evaluate
-- @('selfDescribe' 'id')@ to retrieve the description without modifying it.
selfLabel :: (Strict.Text -> Strict.Text) -> Script model Strict.Text
selfLabel f = scriptModify (scriptRole . roleLabel %~ f) >> scriptGetsRole theRoleLabel

----------------------------------------------------------------------------------------------------

-- | A function of type 'OnQueue' is an instruction to modify the behavior of a 'TypedActor', in
-- other words, it sets an event handler on a 'TypedActor'. The @action@ type variables of this
-- function type is an event handler function type, which will be one of 'DrawAction',
-- 'EventAction', or 'AnimateAction'.
--
-- All 'OnQueue' functions take a continuation function that takes the currently installed @action@
-- event handler function (if any) and returns a new @action@ event handler which may or may not
-- evaluate the currently installed function as part of it's behavior.
--
-- An 'OnQueue' function evaluates to a 'Script' type, so any function of type 'OnQueue' can be used
-- to define a function of type 'Script', as long as you pass to the 'OnQueue' a continuation
-- function of the expected type.
type OnQueue action model = (Maybe (action model) -> action model) -> Script model ()

-- | not for export
--
-- A function that constructs an 'OnQueue' function.
onQueue :: Lens' (Role model) (Maybe (action model)) -> OnQueue action model
onQueue lens f = scriptModify $ scriptRole . cloneLens lens %~ Just . f

-- | Alter the drawing function of the 'TypedActor', that is the action to perform whenever the
-- 'Role' needs to be redrawn.
onDraw :: OnQueue DrawAction model
onDraw = onQueue actionDraw

-- | Alter the selection behavior of the 'TypedActor'.
--
-- Any object that responds to clicks needs a function to decide whether the click lands on the
-- selectable portion of the 'Role's visualization, this field sets that function.
--
-- 'Role's are required to separate the logic that determines whether it's visualization is
-- selectable and the logic that decides whether the 'Role' responds to an event. To enforce this
-- rule, if a 'Role's 'actionSelect' is 'Nothing', or is a 'Script' that evaluates to 'empty', the
-- 'Role' will not be passed any events. A 'Script' that evaluates to @('pure' ())@ indicates that
-- the mouse event can select the 'Role'.
--
-- Of course, you can make a 'Role' receive focus programmatically, in which case it can respond to
-- keyboard events.
onSelect :: OnQueue (EventAction SampCoord) model
onSelect = onQueue actionSelect

-- | Alter the keyboard event handler function.
onKeyboard :: OnQueue (EventAction Keyboard) model
onKeyboard = onQueue actionKeyboard

-- | Alter the mouse action button single-click event handler function. The mouse action button is
-- usually the left mouse button.
onClick :: OnQueue (EventAction Mouse) model
onClick = onQueue actionClick

-- | Alter the mouse action button single-click event handler function. The mouse action button is
-- usually the left mouse button.
onDoubleClick :: OnQueue (EventAction Mouse) model
onDoubleClick = onQueue actionDoubleClick

-- | Alter the mouse context menu button event handler function. The mouse context menu button is
-- usually the right mouse button.
onRightClick :: OnQueue (EventAction Mouse) model
onRightClick = onQueue actionRightClick

-- | Alter the mouse-over event handler function, which is an event that occurs if the mouse is
-- moving over the drawn graphical representation of the 'TypedActor', but none of the mouse buttons
-- are depressed.
onMouseOver :: OnQueue (EventAction Mouse) model
onMouseOver = onQueue actionMouseOver

-- | Alter the mouse-drag event handler function, which is an event that occurs when a mouse drag
-- action begins while the mouse action button (usually the left mouse button) is depressed and
-- begins moving while cursor is over the 'TypedActor's drawn graphical representation in the scene.
onMouseDrag :: OnQueue (EventAction Mouse) model
onMouseDrag = onQueue actionMouseDrag

-- | If any 'TypedActor' in a 'Scene' has an animation type event handler set, an animation event
-- loop is enabled, and animation frame step events are broadcast to all 'TypedActor's who have set
-- this event handler, repeatedly and at very fast regular intervals.
onAnimate :: OnQueue (EventAction UTCTime) model
onAnimate = onQueue actionAnimation

---- | Set to 'True' if any part of the 'scriptRole' is changed.
--scriptRoleUpdated :: Lens' (ScriptState model) Bool
--scriptRoleUpdated = lens theScriptRoleUpdated $ \ a b -> a{ theScriptRoleUpdated = b }

---- | Use a lens to modify something in the 'Scene'
--scriptModifyScene :: Lens' Scene thing -> (thing -> IO thing) -> Script any ()
--scriptModifyScene lens f = Script $ lift $
--  use (scriptScene . cloneLens lens) >>=
--  liftIO . f >>=
--  assign (scriptScene . cloneLens lens)

----------------------------------------------------------------------------------------------------

data ProjectorEnv model
  = ProjectorEnv
    { theProjectorRole :: Role model
    , theProjectorViewBounds :: Rect2D SampCoord
    }

-- | 'Projector' is a type for drawing and animation functions, so called in keeping with the
-- thematic metaphor of theater. An 'Actor' has it's image projected onto the canvas by a
-- 'Projector' function.
--
-- A 'Projector' function is actually very similar to a 'Script' function in that it dictates the
-- appearence of an 'Actor' in a 'Scene'. But where a 'Script' instructs an 'Actor' on how to
-- behave, a 'Projector' instructs the 'Actor' on how to present iteself in the 'Scene'.
--
-- 'Projector' function type instantiates the 'Consequential' typeclass so you can evaluate 'cancel'
-- somwhere in the 'Projector' to indicate that this particular event should no longer be reacted to
-- by an 'Actor'.
newtype Projector model a
  = Projector{ unwrapProjector :: ConsequenceT (ReaderT (ProjectorEnv model) IO) a }
  deriving Functor -- NOT deriving MonadIO

instance Applicative (Projector model) where
  pure = Projector . pure
  (Projector f) <*> (Projector a) = Projector $ f <*> a

instance Monad (Projector model) where
  return = pure
  (Projector a) >>= f = Projector $ a >>= unwrapProjector . f

instance MonadReader model (Projector model) where
  ask = Projector $ theRoleModel . theProjectorRole <$> lift ask
  local f (Projector (ConsequenceT a)) =
    Projector $ ConsequenceT $
    local (projectorRole . roleModel %~ f) a

instance MonadError Strict.Text (Projector model) where
  throwError = Projector . throwError
  catchError (Projector try) catch = Projector $ catchError try $ unwrapProjector . catch

instance MonadFail (Projector model) where { fail = throwError . Strict.pack; }

instance MonadPlus (Projector model) where
  mzero = Projector mzero
  mplus (Projector a) (Projector b) = Projector $ mplus a b

instance Alternative (Projector model) where { empty = mzero; (<|>) = mplus; }

instance Consequential (Projector model) where { cancel = Projector cancel; }

instance Monoid a => Semigroup (Projector model a) where
  a <> b = mappend <$> (a <|> pure mempty) <*> (b <|> pure mempty)

instance Monoid a => Monoid (Projector model a) where { mempty = pure mempty; mappend = (<>); }

runProjector :: Projector model a -> Rect2D SampCoord -> Role model -> IO (Consequence a)
runProjector (Projector project) bounds role =
  runReaderT (runConsequenceT project) $
  ProjectorEnv
  { theProjectorRole = role
  , theProjectorViewBounds = bounds
  }

-- | not for export
projectorIO :: IO a -> Projector any a
projectorIO = Projector . liftIO

-- | Runs a 'Projector' within the current 'Projector' context using a new 'Role'. A new PixSize
-- must be provided, and must intersect with the current 'PixSize' (as is returned by
-- 'getViewSize'). If the two rectangles do not intersect, this function evaluates to 'empty'.
subProjector :: Projector sub a -> Rect2D SampCoord -> Role sub -> Projector model a
subProjector f bounds role =
  getViewBounds >>=
  maybe empty
  ( projectorIO . flip (runProjector f) role >=>
    Projector . consequence
  ) . rect2DIntersect bounds

projectorAsks :: (ProjectorEnv model -> a) -> Projector model a
projectorAsks = Projector . lift . asks

instance Sized2DRaster (Projector model) where
  getViewSize = rect2DSize <$> getViewBounds

-- | The task of a 'Projector' is to draw into a 2D raster image. The size of the raster image in
-- pixels can be retrieved by this function.
getViewBounds :: Projector model (Rect2D SampCoord)
getViewBounds = projectorAsks theProjectorViewBounds

projectorAsksRole :: (Role model -> a) -> Projector model a
projectorAsksRole = projectorAsks . (. theProjectorRole)

projectorRole :: Lens' (ProjectorEnv model) (Role model)
projectorRole = lens theProjectorRole $ \ a b -> a{ theProjectorRole = b }

---- | Create a closure for a 'Script' function that updates a value of type @private@ in reaction to
---- some @event@. This function implements the actual logic for how a closure updates it's private
---- data of type @private@ using the public data of type @public@. Except for 'encloseDrawAction',
---- all other "staging" functions call into this function. Although 'encloseDrawAction' has nearly
---- identical logic to 'encloseEventScript' it is a reader monad rather than a state monad, so must
---- be treated slightly differently.
--encloseEventProjector
--  :: IORef (Role private)
--  -> (event -> Projector private a)
--  -> (event -> Projector public a)
--encloseEventProjector ref act event = Projector $ ConsequenceT $ ReaderT $ \ env ->
--  readIORef ref >>= runProjector (act event) (theProjectorViewBounds env)

----------------------------------------------------------------------------------------------------

-- | A 'Role' contains some arbitrary typed @model@ data, and a set of event handlers that can
-- operate on this data.
--
-- In object oriented programming terms, this data type is more of a class than an object that
-- intantiates the class. The 'actor' and 'actress' functions creates an instance of the class
-- within a 'Scene'.
data Role model
  = Role
    { theRoleModel         :: !model
    , theRoleLabel         :: !Strict.Text
    , theActionDraw        :: !(Maybe (DrawAction model))
    , theActionSelect      :: !(Maybe (EventAction SampCoord model))
    , theActionKeyboard    :: !(Maybe (EventAction Keyboard model))
    , theActionClick       :: !(Maybe (EventAction Mouse model))
    , theActionDoubleClick :: !(Maybe (EventAction Mouse model))
    , theActionRightClick  :: !(Maybe (EventAction Mouse model))
    , theActionMouseOver   :: !(Maybe (EventAction Mouse model))
    , theActionMouseDrag   :: !(Maybe (EventAction Mouse model))
    , theActionAnimation   :: !(Maybe (EventAction UTCTime model))
    }

-- | Expresses information about which event handlers in a 'TypedActor' are set as an integer so
-- that the number of 'Role's that respond to a particular event type can be counted. This is used
-- to determine whether a group of 'Role's in a 'Scene' itself needs to maintain the event handler
-- in the 'Happlet' environment.
--
-- Some event handlers, for example 'theActionKeyboard' or 'theActionDoubleClick' are only triggered
-- if they have focus, i.e. the 'Scene' has the object set in 'theSceneFocus', these event handlers
-- do not need to be included in the stats. Only event handlers that are triggered by iterating over
-- all objects in a 'Scene' need to included in the stats data structure.
data ActorEventHandlerStats
  = ActorEventHandlerStats
    { countActors :: !Int
      -- ^ Does the actor exist? This is here to simply count the number of 'Actor's in a
      -- 'Scene'. It is zero only if this 'ActorEventHandlerStats' value is 'mempty'.
    , countActionDraw        :: !Int
      -- ^ Non-zero if an 'Actor' is visible, meaning it responds to redraw event actions.
    , countActionSelect      :: !Int
      -- ^ Non-zero if an 'Actor' responds to selection actions
    , countActionKeyboard    :: !Int
      -- ^ Non-zero if an 'Actor' responds to 'Keyboard' actions
    , countActionClick       :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse action button click actions
    , countActionDoubleClick :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse action button double-click actions
    , countActionRightClick  :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse context menu button click actions
    , countActionMouseOver   :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse-over events
    , countActionMouseDrag   :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse drag events
    , countActionAnimation   :: !Int
      -- ^ Non-zero if an 'Actor' responds to animation step events
    }

instance Monoid ActorEventHandlerStats where
  mappend = (<>)
  mempty = ActorEventHandlerStats
    { countActors            = 0
    , countActionDraw        = 0
    , countActionSelect      = 0
    , countActionKeyboard    = 0
    , countActionClick       = 0
    , countActionDoubleClick = 0
    , countActionRightClick  = 0
    , countActionMouseOver   = 0
    , countActionMouseDrag   = 0
    , countActionAnimation   = 0
    }

instance Semigroup ActorEventHandlerStats where
  a <> b = let add f = f a + f b in ActorEventHandlerStats
    { countActors            = add countActors
    , countActionDraw        = add countActionDraw
    , countActionSelect      = add countActionSelect
    , countActionKeyboard    = add countActionKeyboard
    , countActionClick       = add countActionClick
    , countActionDoubleClick = add countActionDoubleClick
    , countActionRightClick  = add countActionRightClick
    , countActionMouseOver   = add countActionMouseOver
    , countActionMouseDrag   = add countActionMouseDrag
    , countActionAnimation   = add countActionAnimation
    }

diffActorEventHandlerStats
  :: ActorEventHandlerStats
  -> ActorEventHandlerStats
  -> ActorEventHandlerStats
diffActorEventHandlerStats a b =
  let diff f a b = if f a < f b then 1 else if f a > f b then -1 else 0 in
  ActorEventHandlerStats
  { countActors            = diff countActors a b
  , countActionDraw        = diff countActionDraw a b
  , countActionSelect      = diff countActionSelect a b
  , countActionKeyboard    = diff countActionKeyboard a b
  , countActionClick       = diff countActionClick a b
  , countActionDoubleClick = diff countActionDoubleClick a b
  , countActionRightClick  = diff countActionRightClick a b
  , countActionMouseOver   = diff countActionMouseOver a b
  , countActionMouseDrag   = diff countActionMouseDrag a b
  , countActionAnimation   = diff countActionAnimation a b
  }

roleEventStats :: forall any . Role any -> ActorEventHandlerStats
roleEventStats r = ActorEventHandlerStats
  { countActors            = 1
  , countActionDraw        = inc theActionDraw
  , countActionSelect      = inc theActionSelect
  , countActionKeyboard    = inc theActionKeyboard
  , countActionClick       = inc theActionClick
  , countActionDoubleClick = inc theActionDoubleClick
  , countActionRightClick  = inc theActionRightClick
  , countActionMouseOver   = inc theActionMouseOver
  , countActionMouseDrag   = inc theActionMouseDrag
  , countActionAnimation   = inc theActionAnimation
  } where
    inc :: (Role any -> Maybe void) -> Int
    inc fromRole = maybe 0 (const 1) (fromRole r)

---- | Returns 'True' if there is at least 1 mouse event handler for any of 'countActionClick',
---- 'countActionDoubleClick', 'countActionRightClick', 'countActionMouseOver', or
---- 'countActionMouseDrag'.
--roleEventStatsAnyMouse :: ActorEventHandlerStats -> Bool
--roleEventStatsAnyMouse stats =
--  let test f = f stats > 0 in
--  test countActionClick       ||
--  test countActionDoubleClick ||
--  test countActionRightClick  ||
--  test countActionMouseOver   ||
--  test countActionMouseDrag

-- | not for export
--
-- A function you can use to define a widget using do-notation and lens 'State' operators like
-- '.=', '%=', and 'use'
role :: model -> Role model
role model = Role
  { theRoleModel         = model
  , theRoleLabel         = ""
  , theActionDraw        = Nothing
  , theActionSelect      = Nothing
  , theActionKeyboard    = Nothing
  , theActionClick       = Nothing
  , theActionDoubleClick = Nothing
  , theActionRightClick  = Nothing
  , theActionMouseOver   = Nothing
  , theActionMouseDrag   = Nothing
  , theActionAnimation   = Nothing
  }

-- | A lens to inspect and update the model inside of the 'Role'.
roleModel :: Lens' (Role model) model
roleModel = lens theRoleModel $ \ a b -> a{ theRoleModel = b }

-- | An arbitrary string label you can use to query 'Roles' in a set. Labels do not need to be
-- unique.
roleLabel :: Lens' (Role model) Strict.Text
roleLabel = lens theRoleLabel $ \ a b -> a{ theRoleLabel = b }

actionDraw :: Lens' (Role model) (Maybe (DrawAction model))
actionDraw = lens theActionDraw $ \ a b -> a{ theActionDraw = b }

actionSelect :: Lens' (Role model) (Maybe (EventAction SampCoord model))
actionSelect = lens theActionSelect $ \ a b -> a{ theActionSelect = b }

actionKeyboard :: Lens' (Role model) (Maybe (EventAction Keyboard model))
actionKeyboard = lens theActionKeyboard $ \ a b -> a{ theActionKeyboard = b }

actionClick :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionClick = lens theActionClick $ \ a b -> a{ theActionClick = b }

actionDoubleClick :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionDoubleClick = lens theActionDoubleClick $ \ a b -> a{ theActionDoubleClick = b }

actionRightClick :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionRightClick = lens theActionRightClick $ \ a b -> a{ theActionRightClick = b }

actionMouseOver :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionMouseOver = lens theActionMouseOver $ \ a b -> a{ theActionMouseOver = b }

actionMouseDrag :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionMouseDrag = lens theActionMouseDrag $ \ a b -> a{ theActionMouseDrag = b }

-- | Set the action to perform when an animation step occurs.
actionAnimation :: Lens' (Role model) (Maybe (EventAction UTCTime model))
actionAnimation = lens theActionAnimation $ \ a b -> a{ theActionAnimation = b }

----------------------------------------------------------------------------------------------------

data EventAction event model
  = EventAction
    { theActionText :: !Strict.Text
      -- ^ The source code that defined this action, if any.
    , theAction :: !(event -> Script model ())
    }

-- | Create a closure for a 'Script' function that updates a value of type @private@ in reaction to
-- some @event@. This function implements the actual logic for how a closure updates it's private
-- data of type @private@ using the public data of type @public@. Except for 'encloseDrawAction',
-- all other "staging" functions call into this function. Although 'encloseDrawAction' has nearly
-- identical logic to 'encloseEventScript' it is a reader monad rather than a state monad, so must
-- be treated slightly differently.
encloseEventScript
  :: IORef (Role private)
  -> (event -> Script private a)
  -> (event -> Script public a)
encloseEventScript ref act event = Script $ ConsequenceT $ StateT $ \ public -> do
  privateRole <- readIORef ref
  (a, privateState) <- runScript (act event) ScriptState
    { theScriptRole        = privateRole
    , theScriptAct         = theScriptAct   public
    , theScriptRoleUpdated = False
    }
  writeIORef ref $ theScriptRole privateState
  return
    ( a
    , public
      { theScriptAct = theScriptAct privateState
      , theScriptRoleUpdated = theScriptRoleUpdated privateState
      }
    )

-- | Evaluates an 'EventAction' function.
runEventAction :: EventAction event model -> event -> Script model ()
runEventAction (EventAction{theAction=act}) = act

-- | Create a closure around an 'EventAction' function, hiding the data of type @private@. This
-- function calls 'encloseEventScript' to create the closure.
encloseEventAction
  :: IORef (Role private)
  -> EventAction event private
  -> EventAction event public
encloseEventAction ref (EventAction{theActionText=txt,theAction=act}) = EventAction
  { theActionText = txt
  , theAction     = encloseEventScript ref act
  }

----------------------------------------------------------------------------------------------------

-- | A function used to draw a @model@ to the canvas.
data DrawAction model
  = DrawConst [Draw2DPrimitive SampCoord]
  | DrawAction
    { drawActionText :: Strict.Text
    , drawAction :: Projector model [Draw2DPrimitive SampCoord]
    }

runDrawActionGUI
  :: (Happlet2DGraphics render, Sized2DRaster render, MonadIO render)
  => Role model -> Maybe (Rect2D SampCoord) -> DrawAction model -> render (Consequence ())
runDrawActionGUI role clipbox draw = do
  bounds <- ($ rect2D) . (rect2DHead .~) <$> getViewSize
  liftIO (runProjector (runDrawAction clipbox draw) bounds role) >>= \ case
    ActionOK drawing -> ActionOK <$> draw2D clipbox drawing
    otherwise        -> return $ const (error "internal: runDrawActionGUI") <$> otherwise

runDrawAction
  :: Maybe (Rect2D SampCoord)
  -> DrawAction model
  -> Projector model [Draw2DPrimitive SampCoord]
runDrawAction _clipbox = \ case
  DrawConst             draw  -> pure draw
  DrawAction{drawAction=draw} -> draw

-- | Convert a 'DrawAction' to one that ignores it's input @model@ and always takes the @model@ from
-- an 'IORef'.
encloseDrawAction
  :: IORef (Role private)
  -> DrawAction private
  -> DrawAction public
encloseDrawAction ref = \ case
  DrawConst draw -> DrawConst draw
  DrawAction{drawActionText=txt,drawAction=draw} -> DrawAction
    { drawActionText = txt
    , drawAction = Projector $ ConsequenceT $ ReaderT $ \ env ->
        readIORef ref >>= runProjector draw (theProjectorViewBounds env)
    }

----------------------------------------------------------------------------------------------------

-- | An 'Actor' is anything that can be made visible and interactive on a Happlets 'Scene'
-- canvas. An 'Actor' is essentially an untyped "object" (or in functional programming terms, a
-- "closure") which contains some arbitrary @model@ data that is private or hidden, but behaves
-- according to this @model@. Every 'Actor' is constructed from a 'TypedActor' for which the @model@
-- data type is known to the type system and can be manipulated directly.
--
-- The benefit of using an 'Actor', as opposed to a 'TypedActor' is that an 'Actor' is a simple
-- concrete type (it has no type variable indicating it's internal state), so you can store 'Actor's
-- that contain many different 'TypedActors' of many different @model@ types in a single
-- 'Data.Traversable.Traversable' data structure like a list or vector, as though that data
-- structure contained heterogeneous data. The disadvantage of using an 'Actor' is that there no way
-- to directly manipulate the @model@ private data.
newtype Actor = Actor (IORef (Role Actor))

-- | This is a typed variant of the 'Actor' data type in which the @model@ data type is attached,
-- allowing you to define 'Script's that manipulate the @model@ directly. In object-oriented
-- programming temrs, the @model@ is the "private data" for the 'Actor' object.
--
-- The 'TypedActor' contains a reference to the untyped 'Actor' which you can retrieve using
-- 'theUntypedActor'. Any changes made to the 'TypedActor' are immediately reflected on the untyped
-- 'Actor'. Any code that maintains a reference to the 'TypedActor' can make updates to the 'Actor's
-- hidden private data @model@ for long as that reference is in scope.
--
-- To create a 'TypedActor' and place it on the Happlets canvas, use the 'actor' function.
data TypedActor model
  = TypedActor
    { theTypedActorRole :: !(IORef (Role model))
    , theUntypedActor   :: !Actor
    }

-- | Delegate or send a redrawing event to the current 'TypedActor' of the 'Projector' function
-- context.
actorRedraw :: Maybe (Rect2D SampCoord) -> Projector model [Draw2DPrimitive SampCoord]
actorRedraw clipbox =
  projectorAsksRole theActionDraw >>= maybe (pure []) (runDrawAction clipbox)

-- | Delegate or send a new 'Keyboard' event to the current 'TypedActor' of the 'Script' function
-- context.
actorKeyboard :: Keyboard -> Script model ()
actorKeyboard key =
  scriptGetsRole theActionKeyboard >>= maybe (pure ()) (flip runEventAction key)

-- | Delegate or send a new 'Mouse' click event to the current 'TypedActor' of the 'Script' function
-- context.
actorClick :: Mouse -> Script model ()
actorClick mouse =
  scriptGetsRole theActionClick >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' double click event to the current 'TypedActor' of the 'Script'
-- function context.
actorDoubleClick :: Mouse -> Script model ()
actorDoubleClick mouse =
  scriptGetsRole theActionDoubleClick >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' double click event to the current 'TypedActor' of the 'Script'
-- function context.
actorRightClick :: Mouse -> Script model ()
actorRightClick mouse =
  scriptGetsRole theActionRightClick >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' mouse-over event to the current 'TypedActor' of the 'Projector'
-- function context.
actorMouseOver :: Mouse -> Script model ()
actorMouseOver mouse =
  scriptGetsRole theActionMouseOver >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' mouse-drag event to the current 'TypedActor' of the 'Projector'
-- function context.
actorMouseDrag :: Mouse -> Script model ()
actorMouseDrag drag =
  scriptGetsRole theActionMouseDrag >>= maybe (pure ()) (flip runEventAction drag)

-- | Delegate or send a new animation event to the current 'TypedActor' of the 'Projector' function
-- context.
actorAnimate :: UTCTime -> Script model ()
actorAnimate t =
  scriptGetsRole theActionAnimation >>= maybe (pure ()) (flip runEventAction t)

-- | Calls all relevant "enclose" functions to create a closure around an entire 'Role' by creating
-- a closure around an every 'EventAction' or 'DrawAction' function stored within the 'Role'.
encloseRole
  :: IORef (Role private)
  -- ^ the reference that will store the private data of the closure.
  -> Role private
  -- ^ the functions that operate on the private data of the closure.
  -> public
  -- ^ the initial public data value of this closure.
  -> Role public
encloseRole ref pack initPublic = Role
  { theRoleModel         = initPublic
  , theRoleLabel         = ""
  , theActionDraw        = encloseDrawAction  ref <$> theActionDraw        pack
  , theActionSelect      = encloseEventAction ref <$> theActionSelect      pack
  , theActionKeyboard    = encloseEventAction ref <$> theActionKeyboard    pack
  , theActionClick       = encloseEventAction ref <$> theActionClick       pack
  , theActionDoubleClick = encloseEventAction ref <$> theActionDoubleClick pack
  , theActionRightClick  = encloseEventAction ref <$> theActionRightClick  pack
  , theActionMouseOver   = encloseEventAction ref <$> theActionMouseOver   pack
  , theActionMouseDrag   = encloseEventAction ref <$> theActionMouseDrag   pack
  , theActionAnimation   = encloseEventAction ref <$> theActionAnimation   pack
  }

-- | not for export
--
-- This function creates a 'TypedActor' without registering it with a 'Registry' in a 'Scene'.
makeActor :: Role model -> IO (TypedActor model)
makeActor role = do
  roleref <- newIORef role
  actref  <- newIORef $ error "'newActor' failed to initialize reference"
  let actor = Actor actref
  writeIORef actref $ encloseRole roleref role actor
  return TypedActor{ theTypedActorRole = roleref, theUntypedActor = actor }

-- | not for export
--
-- Does not stage the constructed actor.
actor' :: Script model a -> model -> Script any (a, TypedActor model)
actor' init model = do
  scriptState <- scriptGets id
  (err, initState) <- scriptIO $ runScript init $ ScriptState
    { theScriptRole        = role model
    , theScriptAct         = theScriptAct scriptState
    , theScriptRoleUpdated = False
    }
  a <- Script $ ConsequenceT $ state $ const
    ( err
    , scriptState
      { theScriptAct         = theScriptAct initState
      , theScriptRoleUpdated = theScriptRoleUpdated initState
      }
    )
  actor <- scriptIO $ makeActor $ theScriptRole initState
  return (a, actor)

-- | Create a new 'TypedActor' and stages it in the current 'Scene' so that it can start responding
-- to events.
actor :: Script model () -> model -> Script any (TypedActor model)
actor init model = actor' init model >>= \ ((), actor) -> onStage actor >> return actor

-- | Same as the 'actor' function, but for 'actress' the @model@ is constrained to instantiate the
-- 'Monoid' typeclass. So 'actress' does not take an initial @model@ value as the 'TypedActor' will
-- be initialized with the default 'mempty' value.
--
-- The word 'actress' is used here only because it is a shorter name than @monoidActor@, and apart
-- from the 'Monoid' type constraint, there is otherwise no difference between an 'actor' and
-- 'actress'.
actress :: Monoid model => Script model () -> Script any (TypedActor model)
actress = flip actor mempty

----------------------------------------------------------------------------------------------------

-- | A 'Scene' is a model of a 2D canvas containing many 'Actor' objects, within which all can
-- update the canvas and can respond to canvas events. When an 'Act' is first constructed by
-- 'newActHapplet' it already has a new 'Scene' ready to be populated with 'Actor's, so it is not
-- necessary to create a new 'Scene', but keeping 'Actor's organized into 'Scene's and changing
-- between 'Scene's is a good way to keep a user interface less cluttered.
--
-- A 'Scene' itself can be used as the @model@ of a 'TypedActor', so you can use the 'Scene' as an
-- 'Actor' in another scene, and events can be delegated to the 'Scene' through the 'TypedActor'
-- event handler APIs. When you create a 'Scene' using 'newScene', a 'TypedActor' containing the
-- 'Scene' is returned.
data Scene
  = Scene
    { theSceneRegistry   :: !(Registry (Role Actor))
      -- ^ The objects in this scene
    , theSceneFocus      :: !(Maybe (Role Actor))
      -- ^ A reference to the object in 'theSceneRegistry' that currently responds to keyboard
      -- events or double-click events. Also, an object that is being dragged necessarily has focus.
    , theSceneStats      :: !ActorEventHandlerStats
    , sceneWriteErrorLog :: !(ReportLevel -> Strict.Text -> IO ())
    }

-- | TODO: move this into the GUI module.
data ReportLevel = DEBUG | ERROR | WARN | INFO
  deriving (Eq, Ord, Show, Enum)

-- | TODO: move this into the GUI module.
class Monad m => CanWriteReports m where
  report :: ReportLevel -> Strict.Text -> m ()

instance CanWriteReports (Script any) where
  report lvl msg = scriptGetsScene sceneWriteErrorLog >>= \ log -> scriptIO $ log lvl msg

instance CanWriteReports (GUI provider Scene) where
  report lvl msg =
    gets sceneWriteErrorLog >>= \ log -> liftIO $ log lvl msg

-- | not for export
--
-- The Registry for the 'Scene' contains a reference to all 'Actors'.
sceneRegistry :: Lens' Scene (Registry (Role Actor))
sceneRegistry = lens theSceneRegistry $ \ a b -> a{ theSceneRegistry = b }

-- | The 'Actor' that currently has focus.
sceneFocus :: Lens' Scene (Maybe (Role Actor))
sceneFocus = lens theSceneFocus $ \ a b -> a{ theSceneFocus = b }

-- | not for export
--
-- Tracks statistics on how many elements in a 'Scene' respond to particular events. It is
-- determined by an aggregate computation over all @('Role' 'Actor')@ items in a 'Scene's
-- 'Registry'.
sceneStats :: Lens' Scene ActorEventHandlerStats
sceneStats = lens theSceneStats $ \ a b -> a{ theSceneStats = b }

-- | not for export
--
-- Place an 'Actor' on stage, making it visible and able to respond to events.
stageActor :: Actor -> Script any ()
stageActor (Actor actorRef) = 
  scriptGets (view $ scriptScene . sceneRegistry) >>=
  scriptIO . registryEnqueue actorRef

-- | not for export
--
-- Place a 'TypedActor' on stage, making it visible and able to respond to events. 
onStage :: TypedActor model -> Script any ()
onStage (TypedActor{theUntypedActor=actor}) = stageActor actor

-- | Function used internally by 'newActHapplet' to create a new scene. Scenes that can be
-- manipulated by end users of this API are always wrapped in a 'TypedActor'.
makeEmptyScene :: Int -> IO Scene
makeEmptyScene size = do
  registry <- newRegistry size
  errlock  <- newMVar ()
  return Scene
    { theSceneRegistry   = registry
    , theSceneFocus      = Nothing
    , theSceneStats      = mempty
    , sceneWriteErrorLog = \ _ msg ->
        withMVar errlock $ \ () -> hPutStrLn stderr $ Strict.unpack msg
    }

-- | Like the 'Control.Exception.bracket' function, evaluates a 'Script' function, but ensures a
-- resource is released if the 'Script' function fails. If the resource releasing function also
-- fails, it's failure is ignored. This does not catch exceptions thrown by
-- 'Control.Exception.throw' or 'error'.
sceneBracket
  :: Script any resource
  -> (resource -> Script any ())
  -> (resource -> Script any a)
  -> Script any a
sceneBracket acquire release f0 =
  acquire >>= \ resource ->
  let (Script (ConsequenceT releaseResource)) = release resource in
  let (Script (ConsequenceT f)) = f0 resource in
  Script $ ConsequenceT $ f <* releaseResource

-- | not for export
--
-- Does not stage the constructed .actor
sceneToTypedActor :: Script Scene a -> Scene -> Script any (a, TypedActor Scene)
sceneToTypedActor init = 
  let getActCurrentScene = scriptGetsScene id in
  let putActCurrentScene = scriptModify . ((scriptAct . actCurrentScene) .~) in
  actor'
  ( sceneBracket getActCurrentScene putActCurrentScene $
    const $
    -- This new scene needs to become monad state for the 'Script', however there are not (and must
    -- not) be any APIs that can modify a 'Scene' value directly. So although it is stored as the
    -- monad state, it is the copy in the 'Act's current 'Scene' that should be returned, because
    -- this is the one that is modified (indirectly) by the public APIs.
    get >>= putActCurrentScene >>
    -- Initialization may make updates the new scene.  Just to be
    init >>= \ a ->
    sceneUpdateAllHandlers >>
    -- safe, the 'Scene' in the current 'Act's that was updated by 'init' is now put into the monad
    -- state of the 'Script'.
    getActCurrentScene >>= put >>
    return a
  )

-- | A 'Scene' is a sub-group of 'Actors' that can be created within the current top-level
-- 'Scene'. This function creates an empty 'Scene' with space pre-allocated for an integer number of
-- 'Actor's to be stored, although 16 is the minimum pre-allocation size. It then evaluates an
-- initializer function that should fill the 'Scene' with 'Actor's.
--
-- The state value of the 'Script' continuation will be a value of the 'Scene' data type, but there
-- will not be much you can do to manipulate it directly. The 'Script' continuation given here for
-- the most part will simply call 'actor' or 'actress' to place actors into the scene.
newScene :: Int -> Script Scene () -> Script any (TypedActor Scene)
newScene size init =
  scriptIO (makeEmptyScene size) >>=
  sceneToTypedActor init >>= \ ((), actor) ->
  onStage actor >>
  return actor

-- | not for export
--
-- Checks 'theSceneStats' and installs the correct event handlers to delegate events.
sceneUpdateAllHandlers :: Script Scene ()
sceneUpdateAllHandlers = do
  upd countActionDraw actionDraw $ DrawAction
    { drawActionText = ""
    , drawAction =
        getViewBounds >>= \ bounds ->
        projectorAsksRole (theSceneRegistry . theRoleModel) >>=
        Projector .
        reactEventRegistry True []
        (\ _halt role ->
           join $ maybe
           (pure $ pure ActionHalt)
           ( lift .
             unwrapProjector .
             (\ f -> subProjector f bounds role) .
             runDrawAction Nothing >=> \ draw ->
             pure (modify (<> draw) >> pure ActionHalt)
           )
           (theActionDraw role)
        )
    }
  -- TODO: the rest of the 'upd' functions
  where
  upd
    :: (ActorEventHandlerStats -> Int)
    -> Lens' (Role Scene) (Maybe handler)
    -> handler
    -> Script Scene ()
  upd count lens handler =
    scriptGetsScene (view sceneStats) >>= \ stats ->
    Script $ lift $
    scriptRole . cloneLens lens .=
    if count stats > 0 then Just handler else Nothing

----------------------------------------------------------------------------------------------------

-- | This is the Reader environment that can be inspected within an 'ActorSelect' function using the
-- 'ask' or 'asks' function. 
data ActorInfo
  = ActorInfo
    { actorEvents :: ActorEventHandlerStats
    , actorLabel :: !Strict.Text
    }

-- | This function type is used by the 'selectInScene' function. This function should inspect the
-- 'ActorInfo' value provided by way of the 'ask' or 'asks' function. Return a value of type @fold@
-- to select the 'Actor', all returned values are combined using 'mappend', and the inspected
-- 'Actor' is stored in the new 'Scene' as a side effect. Evaluate to 'empty' to ignore the 'Actor'
-- (it will not be stored in the new 'Scene'). Evaluate to 'cancel' to halt the loop.
newtype ActorSelect a = ActorSelect (ReaderT ActorInfo (ConsequenceT IO) a)
  deriving (Functor, Applicative, Monad, MonadReader ActorInfo, MonadFail)

instance Consequential ActorSelect where { cancel = ActorSelect $ lift cancel; }

-- | This function constructs a new 'Scene' by scanning through the current 'Scene' in the 'Script'
-- context and picking out all 'Actor's that satisfy an 'ActorSelect' function.
--
-- The new 'Scene' is not staged or made visible, call 'onStage' on the result of this function if
-- you want it to be satged.
selectInScene
  :: Monoid fold
  => ActorSelect fold
  -> fold
  -> Script any (TypedActor Scene, fold)
selectInScene (ActorSelect select) fold = Script $ do
  scene <- liftIO $ makeEmptyScene 16
  fold  <- reactEventRegistry True fold
    (\ halt role ->
       liftIO
       ( runConsequenceT $
         runReaderT select
         ActorInfo
         { actorEvents = roleEventStats role
         , actorLabel  = theRoleLabel role
         }
       ) >>= \ case
        ActionOK  fold -> do
          modify (<> fold)
          lift $ unwrapScript $ stageActor $ theRoleModel role
          return ActionHalt
        ActionHalt     -> return ActionHalt
        ActionCancel   -> halt ActionCancel
        ActionFail msg -> halt $ ActionFail msg
    )
    (theSceneRegistry scene)
  (fold, actor) <- unwrapScript $ sceneToTypedActor (return fold) scene
  return (actor, fold)

----------------------------------------------------------------------------------------------------

-- | An 'Act' (noun) is a container with 1 or more 'Scene's. This is the root object of the
-- 'Happlet'.
data Act
  = Act
    { theActCurrentScene    :: !Scene
    , theCurrentMouseStatus :: !MouseStatus
    , theLatestMouseTime    :: !UTCTime
    , theCurrentDragItem    :: !(Maybe (Role Actor))
    , thePreviousMouseEvent :: !(Maybe Mouse)
    , theLatestMouseEvent   :: !(Maybe Mouse)
      -- ^ Used for timing mouse reactions with animations.
    , theActHandleRightClick :: !([Role Actor] -> IO ())
    }

instance CanWriteReports (GUI provider Act) where
  report lvl = onScene . report lvl

type SceneAction fold provider a = FoldMapRegistry (Role Actor) fold (GUI provider Act) a

actLatestMouseTime :: Lens' Act UTCTime
actLatestMouseTime = lens theLatestMouseTime $ \ a b -> a{ theLatestMouseTime = b }

actCurrentMouseStatus :: Lens' Act MouseStatus
actCurrentMouseStatus = lens theCurrentMouseStatus $ \ a b -> a{ theCurrentMouseStatus = b }

actLatestMouseEvent :: Lens' Act (Maybe Mouse)
actLatestMouseEvent = lens theLatestMouseEvent $ \ a b -> a{ theLatestMouseEvent = b }

-- | It is important to understand that once a drag item is selected, that item receives all drag
-- events until it 'cancel's itself. It is also important to understand that if the currently
-- dragged item needs to interact with other items under the mouse cursor, it is up to to the drag
-- event handler to trigger hover events with the current 'PixCoord' value using the
-- 'actMouseHover' function.
actCurrentDragItem :: Lens' Act (Maybe (Role Actor))
actCurrentDragItem = lens theCurrentDragItem $ \ a b -> a{ theCurrentDragItem = b }

actPreviousMouseEvent :: Lens' Act (Maybe Mouse)
actPreviousMouseEvent = lens thePreviousMouseEvent $ \ a b -> a{ thePreviousMouseEvent = b }

actCurrentScene :: Lens' Act Scene
actCurrentScene = lens theActCurrentScene $ \ a b -> a{ theActCurrentScene = b }

onScene :: GUI provider Scene a -> GUI provider Act a
onScene = onSubModel actCurrentScene

-- | Execute a 'Script' within the context of the current 'Act'.
guiInterpretScript
  :: Script model a
  -> TypedActor model
  -> GUI provider Act (Consequence a, Maybe (Role model))
guiInterpretScript script (TypedActor{theTypedActorRole=ioRef}) =
  liftIO (readIORef ioRef) >>=
  guiInterpretScriptRole script

guiInterpretScriptRole
  :: Script model a
  -> Role model
  -> GUI provider Act (Consequence a, Maybe (Role model))
guiInterpretScriptRole script role = do
  act <- get
  (result, state) <- liftIO $
    runScript script ScriptState
    { theScriptRole = role
    , theScriptAct  = act
    , theScriptRoleUpdated = False
    }
  put $ theScriptAct state
  return (result, guard (theScriptRoleUpdated state) >> Just (theScriptRole state))

-- | Execute a 'Projector' function within the context of the current 'Act'.
guiInterpretProjector
  :: Managed provider
  => Projector model a
  -> TypedActor model
  -> GUI provider Act (Consequence a)
guiInterpretProjector direct (TypedActor{theTypedActorRole=ioRef}) =
  rect2DSize <$> getConfig windowSize >>= \ size ->
  liftIO (readIORef ioRef >>= runProjector direct (rect2DHead .~ size $ rect2D))

-- | Iterate through all 'Actor's in a 'Scene's 'Registry' using the 'reactEventRegistry'
-- function. The arguments to this function are mostly the same as 'reactEventRegistry': the first
-- 'Bool' indicates the diretion of the iteration (from zero upward, or downward toward zero).
sceneAction
  :: Bool
  -> fold
  -> ((Consequence (Role Actor) -> SceneAction fold provider void) ->
      Role Actor ->
      SceneAction fold provider (Consequence (Role Actor))
     )
  -> GUI provider Act fold
sceneAction upwards fold act =
  onScene (use sceneRegistry) >>=
  reactEventRegistry upwards fold act

-- | Not for export
--
-- With the given @event@, call the 'EventAction' taken by the given 'Lens', in order of most
-- recently added to least recently added, for each 'Actor's in the current 'Act'. Stop calling
-- 'EventActions' after the first 'EventAction' to return a 'pure' or 'empty' consequence. 
triggerEventHandlers
  :: Lens' (Role Actor) (Maybe (EventAction event Actor))
  -> event
  -> GUI provider Act ()
triggerEventHandlers handler event =
  sceneAction False (mempty :: ActorEventHandlerStats)
  ( \ halt role0 ->
    case role0 ^. handler of
      Nothing     -> return empty
      Just action -> do
        (result, maybeNewRole) <- lift $
          guiInterpretScriptRole (runEventAction action event) role0
        let role = maybe role0 id maybeNewRole
        let updateRole = maybe ActionHalt ActionOK maybeNewRole
        let update roleStats r =
              ( modify $ mappend $!
                diffActorEventHandlerStats (roleEventStats role0) roleStats
              ) >> r
        case result of
          ActionOK   ()  -> update (roleEventStats role) $ halt updateRole
          ActionHalt     -> update (roleEventStats role) $ return updateRole
          ActionCancel   -> do
            let updatedRole = (handler .~ Nothing) role
            update (roleEventStats updatedRole) $ halt $ ActionOK updatedRole
          ActionFail msg -> update mempty $ return $ ActionFail msg
  ) >>=
  onScene . modifying sceneStats . mappend

--triggerRedrawHandlers :: GUI provider Act ()
--triggerRedrawHandlers = do
--  -- TODO
--  return ()

-- | Like 'liftIO' but only works in a the 'GUI' monad for an 'Act' data structure.
actLiftIO :: (Act -> IO a) -> GUI provider Act a
actLiftIO = (get >>=) . (liftIO .)

-- | Use this function to initialize a new 'Act'. This function is of type 'Initialize' so it can
-- only be used at initialization time. It takes an initial model of any value (type variable
-- @init@), creates a 'Scene', and uses the given 'Script' function to initialize the scene.
newActHapplet
  :: init
  -> Script init ()
  -> Initialize Act (Happlet Act)
newActHapplet init f = newHappletIO $ do
  scene <- makeEmptyScene 16
  now   <- getCurrentTime
  let act = Act
        { theActCurrentScene     = scene
        , theLatestMouseTime     = now
        , theCurrentDragItem     = Nothing
        , thePreviousMouseEvent  = Nothing
        , theCurrentMouseStatus  = MouseReady
        , theLatestMouseEvent    = Nothing
        , theActHandleRightClick = const $ pure ()
        }
  runScript f
    ( ScriptState
      { theScriptRole        = role init
      , theScriptAct         = act
      , theScriptRoleUpdated = False
      }
    ) >>= \ case
    (ActionFail err, _ ) -> error $ "app initializer failed: " ++ show err
    (ActionCancel  , st) -> return $ theScriptAct st
    (ActionHalt    , st) -> return $ theScriptAct st
    (ActionOK   () , st) -> return $ theScriptAct st

-- | Use this function with the 'attachWindow' function and the result of 'newActHapplet' to create
-- the OS window.
actWindow
  :: ( CanMouse provider, CanKeyboard provider, CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     )
  => PixSize -> GUI provider Act ()
actWindow _initSize = resetEventHandlers

----------------------------------------------------------------------------------------------------

-- Event handler resets

actResetMouseEvents
  :: ( CanAnimate provider, CanMouse provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     )
  => GUI provider Act ()
actResetMouseEvents =
  theSceneStats <$> use actCurrentScene >>= \ stats ->
  let has f = f stats > 0 in
  let react which = mouseEvents which actMouseHandler in
  if has countActionMouseOver then react MouseAll
  else if has countActionMouseDrag then react MouseDrag
  else if has countActionClick || has countActionDoubleClick then react MouseButton
  else mouseEvents MouseAll $ const cancel

actResetKeyboardEvents :: CanKeyboard provider => GUI provider Act ()
actResetKeyboardEvents = do
  keyboard <- maybe False (const True) <$> onScene (gets theSceneFocus)
  keyboardEvents $ if keyboard then actKeyboardHandler else const cancel

actResetAnimationEvents
  :: ( CanAnimate provider, HappletWindow provider render
     , Managed provider, Happlet2DGraphics render
     )
  => GUI provider Act ()
actResetAnimationEvents =
  theSceneStats <$> use actCurrentScene >>= \ stats ->
  stepFrameEvents $
  if countActionAnimation stats > 0 then actAnimationHandler else const cancel

resetEventHandlers
  :: ( CanMouse provider, CanKeyboard provider, CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     )
  => GUI provider Act ()
resetEventHandlers = do
  actResetMouseEvents
  actResetKeyboardEvents
  actResetAnimationEvents

----------------------------------------------------------------------------------------------------

-- Keyboard handler

-- | Force a 'Keyboard' event to occur in the current 'Act'.
actKeyboardHandler :: Keyboard -> GUI provider Act ()
actKeyboardHandler evt = case evt of
  Keyboard True _ _ -> run evt
  RawKey   True _ _ -> run evt
  _                 -> return ()
  where
  run evt =
    get >>= \ act ->
    case theSceneFocus $ theActCurrentScene act of
      Nothing    -> return ()
      Just  role -> case theActionKeyboard role of
        Nothing     -> return ()
        Just script ->
          guiInterpretScriptRole (runEventAction script evt) role >>= \ (result, role) ->
          let done = sceneFocus .= role in
          onScene $
          case result of
            ActionOK ()    -> done >> return ()
            ActionHalt     -> done >> empty
            ActionCancel   -> sceneFocus .= Nothing >> cancel
            ActionFail msg -> sceneFocus .= Nothing >> throwError msg

----------------------------------------------------------------------------------------------------

-- Animation handler

-- | Force an animation step event to occur in the current 'Act'.
actAnimationHandler
  :: (HappletWindow provider render, Managed provider, Happlet2DGraphics render)
  => UTCTime -> GUI provider Act ()
actAnimationHandler t0 =
  -- If there is an animation handler in effect, mouse actions are stored in 'actNextMouseAction' so
  -- that they may be delayed until the next animation frame event, to ensure mouse events are
  -- synchronized with animation frame events.
  actActualMouseHandler >>
  triggerEventHandlers actionAnimation t0

----------------------------------------------------------------------------------------------------

-- Mouse events

data MouseStatus
  = MouseReady
    -- ^ No events have happend yet, or the last event was executed and we are awaiting incoming
    -- events.
  | MouseMoved
    -- ^ Mouse movement without button click occurred.
  | Mouse1stDown
    -- ^ Mouse button pressed down. This should trigger a click event.
  | Mouse1stUp
    -- ^ Mouse button released after being pressed down.
  | MouseDragged
    -- ^ Mouse button moved while button still down after 1st or 2nd mouse down.
  deriving (Eq, Ord, Show, Enum)

-- | The 'actMouseHandler' has some pretty complex logic in order to make sure the mouse user
-- experience is very consistent across all apps built with the "Happlets.Actor" API.
--
-- Left clicks are de-bounced and timed so that single-click and double-click events can be decoded
-- from the click stream and translated into calls to 'actClick' and 'actDoubleClick'.
--
-- All other mouse actions are checked whether they are button-down or button-up events, and if they
-- are "button-down" (leading edge triggered), the mouse event is sent as it is to the 'actClick'
-- function for all 'Actor's in the 'Scene'.
actMouseHandler
  :: ( CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     )
  => Mouse -> GUI provider Act ()
actMouseHandler new =
  -- TODO: certain constant values have been hard-coded into this function, like the double-click
  -- distance, and the minimum time required to elapse between events for the event to not be
  -- considered a "bounce". These hard-coded values should be taken from a global configuration
  -- variable.
  let minDelayBetweenEvents = 1/16 in
  use actLatestMouseTime >>= \ past ->
  liftIO getCurrentTime >>= \ present ->
  use actLatestMouseEvent >>= \ old ->
  if maybe False (similarMouseEvents new) old &&
     diffUTCTime present past < minDelayBetweenEvents
  then actLatestMouseEvent .= Just new
  else
    use actLatestMouseEvent >>= assign actPreviousMouseEvent >>
    actLatestMouseEvent .= Just new >>
    actLatestMouseTime .= present >>
    stepFrameEvents actAnimationHandler

-- Mouse events that can happen:
-- 1. First down -> set latest event
-- 2. Anomalous close before time-in -> push latest to previous, ignore all but latest
-- 3. Anomalous close after time-in -> ignore any but mouse up, an up generates click + push to previous
-- 4. Anomalous far before time-in -> if down, clear prior state, set new latest event
-- 5. Second down close after time-in -> update state, set latest event
-- 6. Second down far after time-in -> set state to drag event

-- | This is the function that actually executes the mouse action. The mouse action is taken from
-- the 'Act' state field 'theNextMouseAction'.
actActualMouseHandler
  :: (HappletWindow provider render, Managed provider, Happlet2DGraphics render)
  => GUI provider Act ()
actActualMouseHandler =
  liftIO getCurrentTime >>= \ t ->
  use actLatestMouseTime >>= \ t0 ->
  actLatestMouseTime .= t >>
  if diffUTCTime t t0 < 1.0 / 16.0 then return ()
    -- If mouse events occur too close together temporally, simply return without modifying the
    -- mouse state. This will result in the latest mouse event being over-written by the next event
    -- mouse event, but if no next mouse event occurs, this event handler will still be triggered on
    -- the next animation step (since the animation handler is always active while mouse events are
    -- pending) and the latest mouse event will have a chance to be processed then.
  else
  use actLatestMouseEvent >>= \ case
    Nothing -> return ()
    Just new@(Mouse _devID newPressed _newModBits _newButton _newPoint) ->
      use actCurrentMouseStatus >>= \ stat ->
      use actPreviousMouseEvent >>= \ old ->
      let step0 state = do
            actLatestMouseEvent   .= Nothing
            actPreviousMouseEvent .= Just new
            actCurrentMouseStatus .= state
          step state = step0 state >> actCurrentDragItem .= Nothing
          drag = step0 MouseDragged -- like 'step' but doesnt clear the current drag item
      in
      let firstAction = if newPressed then step Mouse1stDown else step MouseMoved in
      case old of
        Nothing -> firstAction
        Just old@(Mouse _devID _oldPressed _oldModBits _oldButton _oldPoint) ->
          let thresh = 8 in -- TODO: make this threshold configurable
          let dist = mouseEventDistance new old in
          case stat of
            MouseReady   -> firstAction
            MouseMoved   ->
              if newPressed
              then step Mouse1stDown
              else step MouseMoved >> actMouseDrag new
            Mouse1stDown ->
              if newPressed then
                if dist > thresh
                then drag >> actMouseDrag new
                else step Mouse1stDown
              else step Mouse1stUp >> actClick new
            Mouse1stUp   ->
              if newPressed
              then step MouseReady >> actDoubleClick new
              else step MouseMoved >> actMouseOver new
            MouseDragged ->
              if newPressed
              then actMouseDrag new
              else step MouseMoved >> actMouseOver new

-- | Force a 'Mouse' action button click event to occur in the current 'Act'.
actClick :: Mouse -> GUI provider Act ()
actClick = triggerEventHandlers actionClick

-- | Force a 'Mouse' context menu button click event to occur in the current 'Act'.
actRightClick :: Mouse -> GUI provider Act ()
actRightClick = triggerEventHandlers actionRightClick

-- | Force a 'Mouse' action button double click event to occur in the current 'Act'.
actDoubleClick :: Mouse -> GUI provider Act ()
actDoubleClick = triggerEventHandlers actionDoubleClick

-- | Force a 'Mouse'-over event to occur in the current 'Act'.
actMouseOver
  :: (HappletWindow provider render, Managed provider, Happlet2DGraphics render)
  => Mouse -> GUI provider Act ()
actMouseOver = triggerEventHandlers actionMouseOver

-- | Force a 'Mouse' drav event to occur in the current 'Act'.
actMouseDrag
  :: (HappletWindow provider render, Managed provider, Happlet2DGraphics render)
  => Mouse -> GUI provider Act ()
actMouseDrag = triggerEventHandlers actionMouseDrag
