-- | This module provides an 'Act', 'Scene', and 'Actor' data types, and the 'Script' function
-- type. Every 'Act' contains a current 'Scene', a 'Script' function type can alter the current
-- 'Scene' of an 'Act' by instructing 'Actor's how to behave. The 'Act' data type is a Happlet that
-- can automatically sets it's own Happlet event handlers based on the needs of the 'Actor's in the
-- current 'Scene'.
--
-- 'Actor' data types have their own internal state values which can only be modified by 'Script'
-- functions. 'Actor's have callbacks for virtual event handlers which are generated by the 'Act' in
-- response to low-level Happlet events. The 'Actor' event callbacks are slightly different from
-- that of the 'Happlet' event handlers, for example, actions for left, right, and double-click
-- mouse actions can be set for each 'Actor' are provided, unlike a 'Happlet' which does not provide
-- a double-click event handler, and which does not provide separate actions for left and right
-- clicks. 'Actor' event handlers also use callback functions of type 'Script', and __not__ of type
-- 'GUI' as a low-level Happlet would.
--
-- 'Act' data values are usually not manipulated directly, they are the @model@ type used by the
-- 'GUI' monad. 'Act's are initialized by 'newActHapplet' and initialized with a function of type
-- 'Script' which places various 'Actors' in their "first positions" (initial states) into the
-- current 'Scene' of the 'Act'. The 'Act' itself handles it's own low-level Happlet events based on
-- the event handlers in use by all 'Actor's in it's current 'Scene'.
module Happlets.Scene
  ( -- ** Acts
    Act, actWindow, newActHapplet, actLiftIO,
    -- ** Scenes
    Scene, newScene, sceneBracket, grabFocus,
    -- *** Selecting Actors in a Scene
    ActorSelect, ActorInfo(..), selectInScene,
    -- ** The Actor data type
    Actor, TypedActor, theUntypedActor, actor, actress, selfLabel,
    -- ** The Script function type
    Script, runScript, scriptWithActor,
    -- ** Event Handlers
    OnQueue, onDraw, scriptRedraw, onSelect, onKeyboard, onAnimate,
    onClick, onDoubleClick, onRightClick, onMouseOver, onMouseDrag,
    -- *** Event Handler Types
    EventAction(..), runEventAction,
    -- *** Sending and Delegating Events
    --
    -- These functions trigger an event handler for the current 'Actor' in the current 'Script'
    -- context using event data that you can synthesize yourself, or capture from another event and
    -- delegate. These functions are only of any use for event handlers that need to execute some
    -- sort of computation, so there are no redraw triggers -- because redrawing only changes the
    -- 'Drawing' data structure for the current 'Actor' it doesn't execute a computation.
    actorAnimate, actorKeyboard, actorClick,
    actorDoubleClick, actorRightClick, actorMouseOver, actorMouseDrag,
    -- *** Actor Event Handler Accounting
    ActorEventHandlerStats,
    countActors, countActionDraw, countActionRedraw, countActionSelect,
    countActionKeyboard, countActionClick, countActionDoubleClick, countActionRightClick,
    countActionMouseOver, countActionMouseDrag, countActionAnimation,
    -- ** Low-Level Happlets APIs
    guiInterpretScript, sceneRedraw, forceSceneRedraw,
    sceneKeyboardHandler, actAnimationHandler,
    sceneClick, actRightClick, sceneDoubleClick,
    sceneMouseOver, sceneMouseDrag,
  ) where

import           Happlets.Initialize (Initialize, newHappletIO)
import           Happlets.Model.GUI (GUI, Happlet, onSubModel)
import           Happlets.Model.Registry
                 ( Registry, newRegistry, registryEnqueue,
                   reactEventRegistry, reactEventRegistryIO
                 )
import           Happlets.View (Happlet2DGraphics(draw2D), HappletWindow(onCanvas))
import           Happlets.View.Types2D
                 ( SampCoord, PixSize,
                   Drawing, drawingIsNull, canonicalize2DShape,
                   rect2DUnion, rect2DUnionNull, theBoundingBox,
                 )
import           Happlets.Control.Animate (CanAnimate(stepFrameEvents))
import           Happlets.Control.Consequence
                 ( Consequential(cancel),
                   Consequence(..), ConsequenceT(..), runConsequenceT
                 )
import           Happlets.Control.Mouse
                 ( CanMouse(mouseEvents), Mouse(..),
                   MouseEventPattern(MouseButton, MouseDrag, MouseAll),
                   similarMouseEvents, mouseEventDistance
                 )
import           Happlets.Control.Keyboard
                 ( CanKeyboard(keyboardEvents),
                   Keyboard(Keyboard, RawKey),
                 )
import           Happlets.Control.WindowManager

import           Control.Applicative (Alternative(..))
import           Control.Concurrent.MVar (newMVar, withMVar)
import           Control.Lens
                 ( Lens', lens, cloneLens, view, set, use, assign, modifying,
                   (&), (^.), (%~), (.~), (.=),
                 )
import           Control.Monad (MonadPlus(..), guard, unless)
import           Control.Monad.Except (MonadError(throwError, catchError))
import           Control.Monad.Fail (MonadFail(fail))
import           Control.Monad.IO.Class (MonadIO(..))
import           Control.Monad.Reader (MonadReader(..), ReaderT(..))
import           Control.Monad.State
                 ( MonadState(state, get, put), StateT(..),
                   gets, modify, runStateT
                 )
import           Control.Monad.Trans (MonadTrans(..))

--import           Data.Functor.Const         (Const(..))
import           Data.IORef (IORef, newIORef, readIORef, writeIORef)
import qualified Data.Text as Strict
import           Data.Time.Clock (UTCTime, getCurrentTime, diffUTCTime)

import           System.IO (hPutStrLn, stderr)

----------------------------------------------------------------------------------------------------

-- | The 'Script' function type is a procedure (a script) that defines the behavior of an 'Actor'
-- while is active in a 'Scene'. The 'Script' operates on a 'TypedActor' containing @model@ state
-- data, and so the 'Script' @model@ type will always be the same as the 'TypedActor's @model@ type.
-- 
-- The 'Script' function type is monadic and instantiates 'MonadState' so that the @model@ data
-- can be inspected and updated using the ordinary 'get', 'put', 'modify', and 'state' functions.
--
-- There are also several APIs defined below, many of which begin with the name "self", which are
-- used to alter the event handlers of the 'TypedActor' that the 'Script' is currently operating on.
--
-- 'Script' instantiates the 'CancelableAction' function, so you can evaluate 'cancel' somwhere in
-- the 'Script' to indicate that this particular event should no longer be reacted to by an 'Actor'.
newtype Script model a
  = Script{ unwrapScript :: ConsequenceT (StateT (ScriptState model) IO) a }
  deriving Functor -- NOT deriving MonadIO

data ScriptState model
  = ScriptState
    { theScriptRole        :: !(Role model) -- ^ The model currently being updated.
    , theScriptActor       :: !Actor
      -- ^ If the 'TypedActor' that is currently executing this script has been staged in a 'Scene',
      -- this value will contain the 'Actor' reference.
    , theScriptScene       :: !Scene -- ^ Access to the 'Scene'.
    , theScriptRoleUpdated :: !Bool
      -- ^ Records whether event handlers (and only event handlers) in 'theScriptRole' have been
      -- modified.
    }

instance Applicative (Script model) where
  pure = Script . pure
  (Script f) <*> (Script a) = Script $ f <*> a

instance Monad (Script model) where
  return = pure
  (Script a) >>= f = Script $ a >>= unwrapScript . f

instance MonadState model (Script model) where
  state f = Script $ do
    (a, widget) <- fmap f $ lift $  use $ scriptRole . roleModel
    lift $ scriptRole . roleModel .= widget
    return a

instance MonadError Strict.Text (Script model) where
  throwError = Script . throwError
  catchError (Script try) catch = Script $ catchError try $ unwrapScript . catch

instance MonadFail (Script model) where { fail = throwError . Strict.pack; }

instance Alternative (Script model) where
  empty = Script empty
  (Script a) <|> (Script b) = Script $ a <|> b

instance MonadPlus (Script model) where { mzero = empty; mplus = (<|>); }

instance Consequential (Script model) where { cancel = Script cancel; }

instance Monoid a => Semigroup (Script model a) where
  a <> b = mappend <$> (a <|> pure mempty) <*> (b <|> pure mempty)

instance Monoid a => Monoid (Script model a) where
  mempty = pure mempty
  mappend = (<>)

-- | Run a 'Script' which performs some update on the @model@.
runScript :: Script model a -> ScriptState model -> IO (Consequence a, ScriptState model)
runScript = runStateT . runConsequenceT . unwrapScript

-- | not for export
scriptIO :: IO a -> Script model a
scriptIO = Script . liftIO

-- | not for export
scriptGets :: (ScriptState model -> a) -> Script model a
scriptGets = Script . lift . gets

scriptModify :: (ScriptState model -> ScriptState model) -> Script model ()
scriptModify = Script . lift . modify

scriptGetsRole :: (Role model -> a) -> Script model a
scriptGetsRole = scriptGets . (. theScriptRole)

scriptGetsScene :: (Scene -> a) -> Script model a
scriptGetsScene = scriptGets . (. theScriptScene)

-- | Access to the @model@ that is being updated by this 'Script'.
scriptRole :: Lens' (ScriptState model) (Role model)
scriptRole = lens theScriptRole $ \ a b -> a{ theScriptRole = b }

-- | Access to the 'Scene' in which this script is being recited.
scriptScene :: Lens' (ScriptState model) Scene
scriptScene = lens theScriptScene $ \ a b -> a{ theScriptScene = b }

-- | A 'TypedActor' allows you to assign an arbitrary text string to it called a "label". This text
-- string can be used for any reason at all, it need not be unique. It is usually used to provide
-- some kind of information to end users about the 'Actor', like what it is and where it originated,
-- or perhaps even the code that constructed it.
--
-- Provide a function for modifying the description, the modified description is returned. Evaluate
-- @('selfDescribe' 'id')@ to retrieve the description without modifying it.
selfLabel :: (Strict.Text -> Strict.Text) -> Script model Strict.Text
selfLabel f = scriptModify (scriptRole . roleLabel %~ f) >> scriptGetsRole theRoleLabel

scriptWithRole
  :: Script other a
  -> Actor
  -> Role other
  -> Script model (Consequence a, Maybe (Role other))
scriptWithRole (Script (ConsequenceT f)) actor role = do
  scriptState <- scriptGets id
  (result, state) <- scriptIO $ runStateT f ScriptState
    { theScriptRole = role
    , theScriptActor = actor
    , theScriptScene = theScriptScene scriptState
    , theScriptRoleUpdated = False
    }
  scriptModify $ scriptScene .~ state ^. scriptScene
  return (result, if theScriptRoleUpdated state then Just (theScriptRole state) else Nothing)

-- | Evaluate a 'Script' function with some other 'TypedActor', which might have a different type
-- than the @model@ in 'Script' of the containing evaluation context. Returns the 'Consequence' of
-- the @'Script' other@ evaluation.
scriptWithActor :: Script other a -> TypedActor other -> Script model (Consequence a)
scriptWithActor f actor = do
  let roleRef = theTypedActorRole actor
  (result, maybeRole) <- scriptIO (readIORef roleRef) >>= scriptWithRole f (theUntypedActor actor)
  maybe (pure ()) (scriptIO . writeIORef roleRef) maybeRole
  return result

-- | Steals the spotlight -- meaning it becomes the target non-mouse events such as keyboard
-- events. This function can be evaluated within the event handler for an 'Actor', it will change
-- the 'sceneFocus' of the current 'Scene' to be the 'Actor' that evaluates this function.
grabFocus :: Script model ()
grabFocus =
  scriptGets theScriptActor >>=
  scriptModify . set (scriptScene . sceneFocus) . Just

----------------------------------------------------------------------------------------------------

-- | While not an 'OnQueue' function, this function can be used to queue a drawing operation for the
-- 'TypedActor' for the current @model@ that is being 'Script'ed. See also the 'scriptRedraw'
-- function, which lets you update the existing 'Drawing' for the current 'TypedActor'.
onDraw :: Drawing SampCoord -> Script model ()
onDraw = scriptModify . set (scriptRole . actionRedraw) . Just

-- | This function accomplishes the same thing as 'onDraw', but allows you to directly manipulate
-- the drawing function that is currently set for the current 'TypedActor'.
scriptRedraw :: (Drawing SampCoord -> Drawing SampCoord) -> Script model ()
scriptRedraw redraw = scriptModify $
  scriptRole %~ \ role -> role &
  actionRedraw .~ Just (redraw $ maybe (role ^. actionDraw) id $ role ^. actionRedraw)

-- | A function of type 'OnQueue' is an instruction to modify the behavior of a 'TypedActor', it
-- sets an 'EventAction' handler for a 'TypedActor'. All 'OnQueue' functions take a continuation
-- function that takes the currently installed 'EventAction' handler function (if any) and returns a
-- new 'EventAction' handler which may or may not evaluate the currently installed function as part
-- of it's behavior.
--
-- An 'OnQueue' function evaluates to a 'Script' type, so any function of type 'OnQueue' can be used
-- within the context of a 'Script', as long as you pass to the 'OnQueue' a continuation function of
-- the expected type.
type OnQueue event model =
      (Maybe (EventAction event model) -> EventAction event model) -> Script model ()

-- | not for export
--
-- A function that constructs an 'OnQueue' function.
onQueue :: Lens' (Role model) (Maybe (EventAction event model)) -> OnQueue event model
onQueue handle f =
  scriptModify $
  (scriptRoleUpdated .~ True) .
  (scriptRole . cloneLens handle %~ Just . f)

-- | Alter the selection behavior of the 'TypedActor'.
--
-- Any object that responds to clicks needs a function to decide whether the click lands on the
-- selectable portion of the 'Role's visualization, this field sets that function.
--
-- 'Role's are required to separate the logic that determines whether it's visualization is
-- selectable and the logic that decides whether the 'Role' responds to an event. To enforce this
-- rule, if a 'Role's 'actionSelect' is 'Nothing', or is a 'Script' that evaluates to 'empty', the
-- 'Role' will not be passed any events. A 'Script' that evaluates to @('pure' ())@ indicates that
-- the mouse event can select the 'Role'.
--
-- Of course, you can make a 'Role' receive focus programmatically, in which case it can respond to
-- keyboard events.
onSelect :: OnQueue SampCoord model
onSelect = onQueue actionSelect

-- | Alter the keyboard event handler function.
onKeyboard :: OnQueue Keyboard model
onKeyboard = onQueue actionKeyboard

-- | Alter the mouse action button single-click event handler function. The mouse action button is
-- usually the left mouse button.
onClick :: OnQueue Mouse model
onClick = onQueue actionClick

-- | Alter the mouse action button single-click event handler function. The mouse action button is
-- usually the left mouse button.
onDoubleClick :: OnQueue Mouse model
onDoubleClick = onQueue actionDoubleClick

-- | Alter the mouse context menu button event handler function. The mouse context menu button is
-- usually the right mouse button.
onRightClick :: OnQueue Mouse model
onRightClick = onQueue actionRightClick

-- | Alter the mouse-over event handler function, which is an event that occurs if the mouse is
-- moving over the drawn graphical representation of the 'TypedActor', but none of the mouse buttons
-- are depressed.
onMouseOver :: OnQueue Mouse model
onMouseOver = onQueue actionMouseOver

-- | Alter the mouse-drag event handler function, which is an event that occurs when a mouse drag
-- action begins while the mouse action button (usually the left mouse button) is depressed and
-- begins moving while cursor is over the 'TypedActor's drawn graphical representation in the scene.
onMouseDrag :: OnQueue Mouse model
onMouseDrag = onQueue actionMouseDrag

-- | If any 'TypedActor' in a 'Scene' has an animation type event handler set, an animation event
-- loop is enabled, and animation frame step events are broadcast to all 'TypedActor's who have set
-- this event handler, repeatedly and at very fast regular intervals.
onAnimate :: OnQueue UTCTime model
onAnimate = onQueue actionAnimation

-- | Set to 'True' if any part of the 'scriptRole' is changed.
scriptRoleUpdated :: Lens' (ScriptState model) Bool
scriptRoleUpdated = lens theScriptRoleUpdated $ \ a b -> a{ theScriptRoleUpdated = b }

---- | Use a lens to modify something in the 'Scene'
--scriptModifyScene :: Lens' Scene thing -> (thing -> IO thing) -> Script any ()
--scriptModifyScene lens f = Script $ lift $
--  use (scriptScene . cloneLens lens) >>=
--  liftIO . f >>=
--  assign (scriptScene . cloneLens lens)

----------------------------------------------------------------------------------------------------

-- | A 'Role' contains some arbitrary typed @model@ data, and a set of event handlers that can
-- operate on this data.
--
-- In object oriented programming terms, this data type is more of a class than an object that
-- intantiates the class. The 'actor' and 'actress' functions creates an instance of the class
-- within a 'Scene'.
data Role model
  = Role
    { theRoleModel         :: !model
    , theRoleLabel         :: !Strict.Text
    , theActionDraw        :: !(Drawing SampCoord)
    , theActionRedraw      :: !(Maybe (Drawing SampCoord))
    , theActionSelect      :: !(Maybe (EventAction SampCoord model))
    , theActionKeyboard    :: !(Maybe (EventAction Keyboard model))
    , theActionClick       :: !(Maybe (EventAction Mouse model))
    , theActionDoubleClick :: !(Maybe (EventAction Mouse model))
    , theActionRightClick  :: !(Maybe (EventAction Mouse model))
    , theActionMouseOver   :: !(Maybe (EventAction Mouse model))
    , theActionMouseDrag   :: !(Maybe (EventAction Mouse model))
    , theActionAnimation   :: !(Maybe (EventAction UTCTime model))
    }

-- | Expresses information about which event handlers in a 'TypedActor' are set as an integer so
-- that the number of 'Role's that respond to a particular event type can be counted. This is used
-- to determine whether a group of 'Role's in a 'Scene' itself needs to maintain the event handler
-- in the 'Happlet' environment.
--
-- Some event handlers, for example 'theActionKeyboard' or 'theActionDoubleClick' are only triggered
-- if they have focus, i.e. the 'Scene' has the object set in 'theSceneFocus', these event handlers
-- do not need to be included in the stats. Only event handlers that are triggered by iterating over
-- all objects in a 'Scene' need to included in the stats data structure.
data ActorEventHandlerStats
  = ActorEventHandlerStats
    { countActors :: !Int
      -- ^ Does the actor exist? This is here to simply count the number of 'Actor's in a
      -- 'Scene'. It is zero only if this 'ActorEventHandlerStats' value is 'mempty'.
    , countActionDraw        :: !Int
      -- ^ Non-zero if an 'Actor' is drawn, meaning it can be drawn to the screen
    , countActionRedraw      :: !Int
      -- ^ Non-zero if an 'Actor' is to be redrawn
--    , countRoleEraseRegion   :: [Rect2D SampCoord]
--      -- ^ Contains the list of bounding rectangles for 'Actor's requesting erasure from the canvas
--      -- before redrawing. When redrawing, this list is used to mask-off the canvas before redrawing
--      -- all elements from back to front.
    , countActionSelect      :: !Int
      -- ^ Non-zero if an 'Actor' responds to selection actions
    , countActionKeyboard    :: !Int
      -- ^ Non-zero if an 'Actor' responds to 'Keyboard' actions
    , countActionClick       :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse action button click actions
    , countActionDoubleClick :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse action button double-click actions
    , countActionRightClick  :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse context menu button click actions
    , countActionMouseOver   :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse-over events
    , countActionMouseDrag   :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse drag events
    , countActionAnimation   :: !Int
      -- ^ Non-zero if an 'Actor' responds to animation step events
    }

instance Monoid ActorEventHandlerStats where
  mappend = (<>)
  mempty = ActorEventHandlerStats
    { countActors            = 0
    , countActionDraw        = 0
    , countActionRedraw      = 0
--    , countRoleEraseRegion   = []
    , countActionSelect      = 0
    , countActionKeyboard    = 0
    , countActionClick       = 0
    , countActionDoubleClick = 0
    , countActionRightClick  = 0
    , countActionMouseOver   = 0
    , countActionMouseDrag   = 0
    , countActionAnimation   = 0
    }

instance Semigroup ActorEventHandlerStats where
  a <> b = let add f = f a + f b in ActorEventHandlerStats
    { countActors            = add countActors
    , countActionDraw       = add countActionDraw
    , countActionRedraw        = add countActionRedraw
    , countActionSelect      = add countActionSelect
--    , countRoleEraseRegion   = countRoleEraseRegion a <> countRoleEraseRegion b
    , countActionKeyboard    = add countActionKeyboard
    , countActionClick       = add countActionClick
    , countActionDoubleClick = add countActionDoubleClick
    , countActionRightClick  = add countActionRightClick
    , countActionMouseOver   = add countActionMouseOver
    , countActionMouseDrag   = add countActionMouseDrag
    , countActionAnimation   = add countActionAnimation
    }

diffActorEventHandlerStats
  :: ActorEventHandlerStats
  -> ActorEventHandlerStats
  -> ActorEventHandlerStats
diffActorEventHandlerStats a b =
  let diff f a b = if f a < f b then 1 else if f a > f b then -1 else 0 in
  ActorEventHandlerStats
  { countActors            = diff countActors a b
  , countActionDraw        = diff countActionDraw a b
  , countActionRedraw      = diff countActionRedraw a b
--  , countRoleEraseRegion   = countRoleEraseRegion a <>
--      ( maybe id
--        (const $ (:) $ theBoundingBox $ countActionDraw b)
--        (countActionRedraw b)
--      ) (countRoleEraseRegion b)
  , countActionSelect      = diff countActionSelect a b
  , countActionKeyboard    = diff countActionKeyboard a b
  , countActionClick       = diff countActionClick a b
  , countActionDoubleClick = diff countActionDoubleClick a b
  , countActionRightClick  = diff countActionRightClick a b
  , countActionMouseOver   = diff countActionMouseOver a b
  , countActionMouseDrag   = diff countActionMouseDrag a b
  , countActionAnimation   = diff countActionAnimation a b
  }

roleEventStats :: forall any . Role any -> ActorEventHandlerStats
roleEventStats r = ActorEventHandlerStats
  { countActors            = 1
  , countActionDraw        = if drawingIsNull (theActionDraw r) then 0 else 1
  , countActionRedraw      = inc theActionRedraw
--  , countRoleEraseRegion   = []
  , countActionSelect      = inc theActionSelect
  , countActionKeyboard    = inc theActionKeyboard
  , countActionClick       = inc theActionClick
  , countActionDoubleClick = inc theActionDoubleClick
  , countActionRightClick  = inc theActionRightClick
  , countActionMouseOver   = inc theActionMouseOver
  , countActionMouseDrag   = inc theActionMouseDrag
  , countActionAnimation   = inc theActionAnimation
  } where
    inc :: (Role any -> Maybe void) -> Int
    inc fromRole = maybe 0 (const 1) (fromRole r)

---- | Returns 'True' if there is at least 1 mouse event handler for any of 'countActionClick',
---- 'countActionDoubleClick', 'countActionRightClick', 'countActionMouseOver', or
---- 'countActionMouseDrag'.
--roleEventStatsAnyMouse :: ActorEventHandlerStats -> Bool
--roleEventStatsAnyMouse stats =
--  let test f = f stats > 0 in
--  test countActionClick       ||
--  test countActionDoubleClick ||
--  test countActionRightClick  ||
--  test countActionMouseOver   ||
--  test countActionMouseDrag

-- | not for export
--
-- A function you can use to define a widget using do-notation and lens 'State' operators like
-- '.=', '%=', and 'use'
role :: model -> Role model
role model = Role
  { theRoleModel         = model
  , theRoleLabel         = ""
  , theActionDraw        = mempty
  , theActionRedraw      = Nothing
  , theActionSelect      = Nothing
  , theActionKeyboard    = Nothing
  , theActionClick       = Nothing
  , theActionDoubleClick = Nothing
  , theActionRightClick  = Nothing
  , theActionMouseOver   = Nothing
  , theActionMouseDrag   = Nothing
  , theActionAnimation   = Nothing
  }

-- | A lens to inspect and update the model inside of the 'Role'.
roleModel :: Lens' (Role model) model
roleModel = lens theRoleModel $ \ a b -> a{ theRoleModel = b }

-- | An arbitrary string label you can use to query 'Roles' in a set. Labels do not need to be
-- unique.
roleLabel :: Lens' (Role model) Strict.Text
roleLabel = lens theRoleLabel $ \ a b -> a{ theRoleLabel = b }

actionDraw :: Lens' (Role model) (Drawing SampCoord)
actionDraw = lens theActionDraw $ \ a b -> a{ theActionDraw = b }

actionRedraw :: Lens' (Role model) (Maybe (Drawing SampCoord))
actionRedraw = lens theActionRedraw $ \ a b -> a{ theActionRedraw = b }

actionSelect :: Lens' (Role model) (Maybe (EventAction SampCoord model))
actionSelect = lens theActionSelect $ \ a b -> a{ theActionSelect = b }

actionKeyboard :: Lens' (Role model) (Maybe (EventAction Keyboard model))
actionKeyboard = lens theActionKeyboard $ \ a b -> a{ theActionKeyboard = b }

actionClick :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionClick = lens theActionClick $ \ a b -> a{ theActionClick = b }

actionDoubleClick :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionDoubleClick = lens theActionDoubleClick $ \ a b -> a{ theActionDoubleClick = b }

actionRightClick :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionRightClick = lens theActionRightClick $ \ a b -> a{ theActionRightClick = b }

actionMouseOver :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionMouseOver = lens theActionMouseOver $ \ a b -> a{ theActionMouseOver = b }

actionMouseDrag :: Lens' (Role model) (Maybe (EventAction Mouse model))
actionMouseDrag = lens theActionMouseDrag $ \ a b -> a{ theActionMouseDrag = b }

-- | Set the action to perform when an animation step occurs.
actionAnimation :: Lens' (Role model) (Maybe (EventAction UTCTime model))
actionAnimation = lens theActionAnimation $ \ a b -> a{ theActionAnimation = b }

----------------------------------------------------------------------------------------------------

data EventAction event model
  = EventAction
    { theActionText :: !Strict.Text
      -- ^ The source code that defined this action, if any.
    , theAction :: !(event -> Script model ())
    }

-- | Create a closure for a 'Script' function that updates a value of type @private@ in reaction to
-- some @event@. This function implements the actual logic for how a closure updates it's private
-- data of type @private@ using the public data of type @public@. Except for 'encloseDrawAction',
-- all other "staging" functions call into this function. Although 'encloseDrawAction' has nearly
-- identical logic to 'encloseEventScript' it is a reader monad rather than a state monad, so must
-- be treated slightly differently.
encloseEventScript
  :: IORef (Role private)
  -> (event -> Script private a)
  -> (event -> Script public a)
encloseEventScript ref act event = Script $ ConsequenceT $ StateT $ \ public -> do
  privateRole <- readIORef ref
  (a, privateState) <- runScript (act event) ScriptState
    { theScriptRole        = privateRole
    , theScriptActor       = theScriptActor public
    , theScriptScene       = theScriptScene public
    , theScriptRoleUpdated = False
    }
  writeIORef ref $ theScriptRole privateState
  return
    ( a
    , public
      { theScriptScene = theScriptScene privateState
      , theScriptRoleUpdated = theScriptRoleUpdated privateState
      }
    )

-- | Evaluates an 'EventAction' function.
runEventAction :: EventAction event model -> event -> Script model ()
runEventAction (EventAction{theAction=act}) = act

-- | Create a closure around an 'EventAction' function, hiding the data of type @private@. This
-- function calls 'encloseEventScript' to create the closure.
encloseEventAction
  :: IORef (Role private)
  -> EventAction event private
  -> EventAction event public
encloseEventAction ref (EventAction{theActionText=txt,theAction=act}) = EventAction
  { theActionText = txt
  , theAction     = encloseEventScript ref act
  }

----------------------------------------------------------------------------------------------------

-- | An 'Actor' is anything that can be made visible and interactive on a Happlets 'Scene'
-- canvas. An 'Actor' is essentially an untyped "object" (or in functional programming terms, a
-- "closure") which contains some arbitrary @model@ data that is private or hidden, but behaves
-- according to this @model@. Every 'Actor' is constructed from a 'TypedActor' for which the @model@
-- data type is known to the type system and can be manipulated directly.
--
-- The benefit of using an 'Actor', as opposed to a 'TypedActor' is that an 'Actor' is a simple
-- concrete type (it has no type variable indicating it's internal state), so you can store 'Actor's
-- that contain many different 'TypedActors' of many different @model@ types in a single
-- 'Data.Traversable.Traversable' data structure like a list or vector, as though that data
-- structure contained heterogeneous data. The disadvantage of using an 'Actor' is that there no way
-- to directly manipulate the @model@ private data.
newtype Actor = Actor (IORef (Role Actor))

-- | This is a typed variant of the 'Actor' data type in which the @model@ data type is attached,
-- allowing you to define 'Script's that manipulate the @model@ directly. In object-oriented
-- programming temrs, the @model@ is the "private data" for the 'Actor' object.
--
-- The 'TypedActor' contains a reference to the untyped 'Actor' which you can retrieve using
-- 'theUntypedActor'. Any changes made to the 'TypedActor' are immediately reflected on the untyped
-- 'Actor'. Any code that maintains a reference to the 'TypedActor' can make updates to the 'Actor's
-- hidden private data @model@ for long as that reference is in scope.
--
-- To create a 'TypedActor' and place it on the Happlets canvas, use the 'actor' function.
data TypedActor model
  = TypedActor
    { theTypedActorRole :: !(IORef (Role model))
    , theUntypedActor   :: !Actor
    }

-- | Delegate or send a new 'Keyboard' event to the current 'TypedActor' of the 'Script' function
-- context.
actorKeyboard :: Keyboard -> Script model ()
actorKeyboard key =
  scriptGetsRole theActionKeyboard >>= maybe (pure ()) (flip runEventAction key)

-- | Delegate or send a new 'Mouse' click event to the current 'TypedActor' of the 'Script' function
-- context.
actorClick :: Mouse -> Script model ()
actorClick mouse =
  scriptGetsRole theActionClick >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' double click event to the current 'TypedActor' of the 'Script'
-- function context.
actorDoubleClick :: Mouse -> Script model ()
actorDoubleClick mouse =
  scriptGetsRole theActionDoubleClick >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' double click event to the current 'TypedActor' of the 'Script'
-- function context.
actorRightClick :: Mouse -> Script model ()
actorRightClick mouse =
  scriptGetsRole theActionRightClick >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' mouse-over event to the current 'TypedActor' of the 'Script'
-- function context.
actorMouseOver :: Mouse -> Script model ()
actorMouseOver mouse =
  scriptGetsRole theActionMouseOver >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' mouse-drag event to the current 'TypedActor' of the 'Script'
-- function context.
actorMouseDrag :: Mouse -> Script model ()
actorMouseDrag drag =
  scriptGetsRole theActionMouseDrag >>= maybe (pure ()) (flip runEventAction drag)

-- | Delegate or send a new animation event to the current 'TypedActor' of the 'Script' function
-- context.
actorAnimate :: UTCTime -> Script model ()
actorAnimate t =
  scriptGetsRole theActionAnimation >>= maybe (pure ()) (flip runEventAction t)

-- | Calls all relevant "enclose" functions to create a closure around an entire 'Role' by creating
-- a closure around an every 'EventAction' or 'DrawAction' function stored within the 'Role'.
encloseRole
  :: IORef (Role private)
  -- ^ the reference that will store the private data of the closure.
  -> Role private
  -- ^ the functions that operate on the private data of the closure.
  -> public
  -- ^ the initial public data value of this closure.
  -> Role public
encloseRole ref pack initPublic = Role
  { theRoleModel         = initPublic
  , theRoleLabel         = ""
  , theActionDraw        = theActionDraw pack
  , theActionRedraw      = theActionRedraw  pack
  , theActionSelect      = encloseEventAction ref <$> theActionSelect      pack
  , theActionKeyboard    = encloseEventAction ref <$> theActionKeyboard    pack
  , theActionClick       = encloseEventAction ref <$> theActionClick       pack
  , theActionDoubleClick = encloseEventAction ref <$> theActionDoubleClick pack
  , theActionRightClick  = encloseEventAction ref <$> theActionRightClick  pack
  , theActionMouseOver   = encloseEventAction ref <$> theActionMouseOver   pack
  , theActionMouseDrag   = encloseEventAction ref <$> theActionMouseDrag   pack
  , theActionAnimation   = encloseEventAction ref <$> theActionAnimation   pack
  }

-- | not for export
--
-- This function creates a 'TypedActor' without registering it with a 'Registry' in a 'Scene'.
makeActor :: Role model -> IO (TypedActor model)
makeActor role = do
  roleref <- newIORef role
  actref  <- newIORef $ error "'newActor' failed to initialize reference"
  let actor = Actor actref
  writeIORef actref $ encloseRole roleref role actor
  return TypedActor{ theTypedActorRole = roleref, theUntypedActor = actor }

-- | not for export
--
-- Does not stage the constructed actor.
actor' :: Script model a -> model -> Script any (a, TypedActor model)
actor' init model = do
  scriptState <- scriptGets id
  (err, initState) <- scriptIO $ runScript init $ ScriptState
    { theScriptRole        = role model
    , theScriptActor       = theScriptActor scriptState
    , theScriptScene       = theScriptScene scriptState
    , theScriptRoleUpdated = False
    }
  a <- Script $ ConsequenceT $ state $ const
    ( err
    , scriptState
      { theScriptScene       = theScriptScene initState
      , theScriptRoleUpdated = theScriptRoleUpdated initState
      }
    )
  actor <- scriptIO $ makeActor $ theScriptRole initState
  return (a, actor)

-- | Create a new 'TypedActor' and stages it in the current 'Scene' so that it can start responding
-- to events.
actor :: Script model () -> model -> Script any (TypedActor model)
actor init model = actor' init model >>= \ ((), actor) -> onStage actor >> return actor

-- | Same as the 'actor' function, but for 'actress' the @model@ is constrained to instantiate the
-- 'Monoid' typeclass. So 'actress' does not take an initial @model@ value as the 'TypedActor' will
-- be initialized with the default 'mempty' value.
--
-- The word 'actress' is used here only because it is a shorter name than @monoidActor@, and apart
-- from the 'Monoid' type constraint, there is otherwise no difference between an 'actor' and
-- 'actress'.
actress :: Monoid model => Script model () -> Script any (TypedActor model)
actress = flip actor mempty

----------------------------------------------------------------------------------------------------

-- | A 'Scene' is a model of a 2D canvas containing many 'Actor' objects, within which all can
-- update the canvas and can respond to canvas events. When an 'Act' is first constructed by
-- 'newActHapplet' it already has a new 'Scene' ready to be populated with 'Actor's, so it is not
-- necessary to create a new 'Scene', but keeping 'Actor's organized into 'Scene's and changing
-- between 'Scene's is a good way to keep a user interface less cluttered.
--
-- A 'Scene' itself can be used as the @model@ of a 'TypedActor', so you can use the 'Scene' as an
-- 'Actor' in another scene, and events can be delegated to the 'Scene' through the 'TypedActor'
-- event handler APIs. When you create a 'Scene' using 'newScene', a 'TypedActor' containing the
-- 'Scene' is returned.
data Scene
  = Scene
    { theSceneRegistry   :: !(Registry (Role Actor))
      -- ^ The objects in this scene
    , theSceneFocus      :: !(Maybe Actor)
      -- ^ A reference to the object in 'theSceneRegistry' that currently responds to keyboard
      -- events or double-click events. Also, an object that is being dragged necessarily has focus.
    , theSceneStats      :: !ActorEventHandlerStats
    , sceneWriteErrorLog :: !(ReportLevel -> Strict.Text -> IO ())
    }

-- | TODO: move this into the GUI module.
data ReportLevel = DEBUG | ERROR | WARN | INFO
  deriving (Eq, Ord, Show, Enum)

-- | TODO: move this into the GUI module.
class Monad m => CanWriteReports m where
  report :: ReportLevel -> Strict.Text -> m ()

instance CanWriteReports (Script any) where
  report lvl msg = scriptGetsScene sceneWriteErrorLog >>= \ log -> scriptIO $ log lvl msg

instance CanWriteReports (GUI provider Scene) where
  report lvl msg =
    gets sceneWriteErrorLog >>= \ log -> liftIO $ log lvl msg

-- | not for export
--
-- The Registry for the 'Scene' contains a reference to all 'Actors'.
sceneRegistry :: Lens' Scene (Registry (Role Actor))
sceneRegistry = lens theSceneRegistry $ \ a b -> a{ theSceneRegistry = b }

-- | The 'Actor' that currently has focus.
sceneFocus :: Lens' Scene (Maybe Actor)
sceneFocus = lens theSceneFocus $ \ a b -> a{ theSceneFocus = b }

-- | not for export
--
-- Tracks statistics on how many elements in a 'Scene' respond to particular events. It is
-- determined by an aggregate computation over all @('Role' 'Actor')@ items in a 'Scene's
-- 'Registry'.
sceneStats :: Lens' Scene ActorEventHandlerStats
sceneStats = lens theSceneStats $ \ a b -> a{ theSceneStats = b }

-- | not for export
--
-- Place an 'Actor' on stage, making it visible and able to respond to events.
stageActor :: Actor -> Script any ()
stageActor (Actor actorRef) = 
  scriptGets (view $ scriptScene . sceneRegistry) >>=
  scriptIO . registryEnqueue actorRef

-- | not for export
--
-- Place a 'TypedActor' on stage, making it visible and able to respond to events. 
onStage :: TypedActor model -> Script any ()
onStage (TypedActor{theUntypedActor=actor}) = stageActor actor

-- | Function used internally by 'newActHapplet' to create a new scene. Scenes that can be
-- manipulated by end users of this API are always wrapped in a 'TypedActor'.
makeEmptyScene :: Int -> IO Scene
makeEmptyScene size = do
  registry <- newRegistry size
  errlock  <- newMVar ()
  return Scene
    { theSceneRegistry   = registry
    , theSceneFocus      = Nothing
    , theSceneStats      = mempty
    , sceneWriteErrorLog = \ _ msg ->
        withMVar errlock $ \ () -> hPutStrLn stderr $ Strict.unpack msg
    }

-- | Like the 'Control.Exception.bracket' function, evaluates a 'Script' function, but ensures a
-- resource is released if the 'Script' function fails. If the resource releasing function also
-- fails, it's failure is ignored. This does not catch exceptions thrown by
-- 'Control.Exception.throw' or 'error'.
sceneBracket
  :: Script any resource
  -> (resource -> Script any ())
  -> (resource -> Script any a)
  -> Script any a
sceneBracket acquire release f0 =
  acquire >>= \ resource ->
  let (Script (ConsequenceT releaseResource)) = release resource in
  let (Script (ConsequenceT f)) = f0 resource in
  Script $ ConsequenceT $ f <* releaseResource

-- | not for export
--
-- Does not stage the constructed .actor
sceneToTypedActor :: Script Scene a -> Scene -> Script any (a, TypedActor Scene)
sceneToTypedActor init =
  actor' $
  init <*
  ( use sceneRegistry >>=
    scriptIO . sceneRecountActionStats >>=
    assign sceneStats
  ) <*
  sceneUpdateAllHandlers

-- | A 'Scene' is a sub-group of 'Actors' that can be created within the current top-level
-- 'Scene'. This function creates an empty 'Scene' with space pre-allocated for an integer number of
-- 'Actor's to be stored, although 16 is the minimum pre-allocation size. It then evaluates an
-- initializer function that should fill the 'Scene' with 'Actor's.
--
-- The state value of the 'Script' continuation will be a value of the 'Scene' data type, but there
-- will not be much you can do to manipulate it directly. The 'Script' continuation given here for
-- the most part will simply call 'actor' or 'actress' to place actors into the scene.
newScene :: Int -> Script Scene () -> Script any (TypedActor Scene)
newScene size init =
  scriptIO (makeEmptyScene size) >>=
  sceneToTypedActor init >>= \ ((), actor) ->
  onStage actor >>
  return actor

sceneRecountActionStats :: Registry (Role Actor) -> IO ActorEventHandlerStats
sceneRecountActionStats registry =
  reactEventRegistryIO True
  (\ _halt role -> modify (mappend $ roleEventStats role) >> return mzero)
  registry
  mempty

-- | not for export
--
-- Checks 'theSceneStats' and installs the correct event handlers to delegate events.
sceneUpdateAllHandlers :: Script Scene ()
sceneUpdateAllHandlers = do
  s <- use sceneStats
  setup s countActionSelect      actionSelect
  setup s countActionKeyboard    actionKeyboard
  setup s countActionClick       actionClick
  setup s countActionDoubleClick actionDoubleClick
  setup s countActionRightClick  actionRightClick
  setup s countActionMouseOver   actionMouseOver
  setup s countActionMouseDrag   actionMouseDrag
  setup s countActionAnimation   actionAnimation
  where
    setup
      :: ActorEventHandlerStats
      -> (ActorEventHandlerStats -> Int)
      -> (forall model . Lens' (Role model) (Maybe (EventAction event model)))
      -> Script Scene ()
    setup s checkStats handle =
      scriptModify $
      scriptRole . cloneLens handle .~
      if checkStats s > 0 then Just (reactScene handle) else Nothing

reactScene
  :: (forall model . Lens' (Role model) (Maybe (EventAction event model)))
  -> EventAction event Scene
reactScene handler =
  EventAction
  { theActionText = ""
  , theAction = triggerEventHandlers scriptIO scriptWithRole handler
  }

----------------------------------------------------------------------------------------------------

-- | This is the Reader environment that can be inspected within an 'ActorSelect' function using the
-- 'ask' or 'asks' function. 
data ActorInfo
  = ActorInfo
    { actorEvents :: ActorEventHandlerStats
    , actorLabel :: !Strict.Text
    }

-- | This function type is used by the 'selectInScene' function. This function should inspect the
-- 'ActorInfo' value provided by way of the 'ask' or 'asks' function. Return a value of type @fold@
-- to select the 'Actor', all returned values are combined using 'mappend', and the inspected
-- 'Actor' is stored in the new 'Scene' as a side effect. Evaluate to 'empty' to ignore the 'Actor'
-- (it will not be stored in the new 'Scene'). Evaluate to 'cancel' to halt the loop.
newtype ActorSelect a = ActorSelect (ReaderT ActorInfo (ConsequenceT IO) a)
  deriving (Functor, Applicative, Monad, MonadReader ActorInfo, MonadFail)

instance Consequential ActorSelect where { cancel = ActorSelect $ lift cancel; }

-- | This function constructs a new 'Scene' by scanning through the current 'Scene' in the 'Script'
-- context and picking out all 'Actor's that satisfy an 'ActorSelect' function.
--
-- The new 'Scene' is not staged or made visible, call 'onStage' on the result of this function if
-- you want it to be satged.
selectInScene
  :: Monoid fold
  => ActorSelect fold
  -> fold
  -> Script any (TypedActor Scene, fold)
selectInScene (ActorSelect select) fold = do
  scene <- scriptIO $ makeEmptyScene 16
  fold  <- reactEventRegistry True
    scriptIO
    (\ halt role ->
       lift
       ( scriptIO $
         runConsequenceT $
         runReaderT select
         ActorInfo
         { actorEvents = roleEventStats role
         , actorLabel  = theRoleLabel role
         }
       ) >>= \ case
        ActionOK  fold -> do
          modify (<> fold)
          lift $ stageActor $ theRoleModel role
          return ActionHalt
        ActionHalt     -> return ActionHalt
        ActionCancel   -> halt ActionCancel
        ActionFail msg -> halt (ActionFail msg)
    )
    (theSceneRegistry scene)
    fold
  (fold, actor) <- sceneToTypedActor (return fold) scene
  return (actor, fold)

----------------------------------------------------------------------------------------------------

-- | An 'Act' (noun) is a container with 1 or more 'Scene's. This is the root object of the
-- 'Happlet'.
data Act
  = Act
    { theActCurrentScene    :: !Scene
    , theCurrentMouseStatus :: !MouseStatus
    , theLatestMouseTime    :: !UTCTime
    , theCurrentDragItem    :: !(Maybe (Role Actor))
    , thePreviousMouseEvent :: !(Maybe Mouse)
    , theLatestMouseEvent   :: !(Maybe Mouse)
      -- ^ Used for timing mouse reactions with animations.
    , theActHandleRightClick :: !([Role Actor] -> IO ())
    }

instance CanWriteReports (GUI provider Act) where
  report lvl = onScene . report lvl

actLatestMouseTime :: Lens' Act UTCTime
actLatestMouseTime = lens theLatestMouseTime $ \ a b -> a{ theLatestMouseTime = b }

actCurrentMouseStatus :: Lens' Act MouseStatus
actCurrentMouseStatus = lens theCurrentMouseStatus $ \ a b -> a{ theCurrentMouseStatus = b }

actLatestMouseEvent :: Lens' Act (Maybe Mouse)
actLatestMouseEvent = lens theLatestMouseEvent $ \ a b -> a{ theLatestMouseEvent = b }

-- | It is important to understand that once a drag item is selected, that item receives all drag
-- events until it 'cancel's itself. It is also important to understand that if the currently
-- dragged item needs to interact with other items under the mouse cursor, it is up to to the drag
-- event handler to trigger hover events with the current 'PixCoord' value using the
-- 'actMouseHover' function.
actCurrentDragItem :: Lens' Act (Maybe (Role Actor))
actCurrentDragItem = lens theCurrentDragItem $ \ a b -> a{ theCurrentDragItem = b }

actPreviousMouseEvent :: Lens' Act (Maybe Mouse)
actPreviousMouseEvent = lens thePreviousMouseEvent $ \ a b -> a{ thePreviousMouseEvent = b }

actCurrentScene :: Lens' Act Scene
actCurrentScene = lens theActCurrentScene $ \ a b -> a{ theActCurrentScene = b }

onScene :: GUI provider Scene a -> GUI provider Act a
onScene = onSubModel actCurrentScene

-- | Execute a 'Script' within the context of the current 'Act'.
guiInterpretScript
  :: Script model a
  -> TypedActor model
  -> GUI provider Scene (Consequence a, Maybe (Role model))
guiInterpretScript script (TypedActor{theTypedActorRole=ioRef,theUntypedActor=actor}) =
  liftIO (readIORef ioRef) >>=
  guiInterpretScriptRole script actor

guiInterpretScriptRole
  :: Script model a
  -> Actor
  -> Role model
  -> GUI provider Scene (Consequence a, Maybe (Role model))
guiInterpretScriptRole script actor role = do
  scene <- get
  (result, state) <- liftIO $
    runScript script ScriptState
    { theScriptRole = role
    , theScriptActor = actor
    , theScriptScene = scene
    , theScriptRoleUpdated = False
    }
  put $ theScriptScene state
  return (result, guard (theScriptRoleUpdated state) >> Just (theScriptRole state))

-- | This function uses 'reactEventRegistry' to step through the event 'Registry' of a 'Scene', uses
-- a lens to select a @thing@ from each 'Role' of each 'Actor' in the 'Registry', and executes a
-- continuation function that 'Role' and that @thing@ for all 'Role's for which the @thing@ is not
-- 'Nothing'. Importantly, this function also udpates the 'ActorEventHandlerStats' for the 'Scene'
-- using the 'diffActorEventHandlerStats' function, which also tracks which 'Actor's need to be
-- redrawn, and thus which regions need to be deleted.
forActorsInRegistry
  :: (Monad m, MonadState Scene m)
  => Bool -- ^ Scan upwards? (Fiven as first argument to 'reactEventRegistry'.)
  -> Bool -- ^ Should halt on first Role to evaluate to a successful 'ActionOK' result.
  -> (forall a . IO a -> m a)
  -> Lens' (Role Actor) (Maybe thing)
  -> (Role Actor -> thing -> m (Consequence (), Maybe (Role Actor)))
  -> m ()
forActorsInRegistry upward haltWhenOK liftIO thingLens runUpdate =
  use sceneRegistry >>= \ registry ->
  ( reactEventRegistry upward liftIO
    (\ halt role0 -> case role0 ^. thingLens of
        Nothing    -> return mzero
        Just thing -> do
          (consequence, maybeNewRole) <- lift $ runUpdate role0 thing
          let role = maybe role0 id maybeNewRole
          let updateRole = maybe ActionHalt ActionOK maybeNewRole
          let update roleStats r =
                ( modify $ mappend $!
                  diffActorEventHandlerStats (roleEventStats role0) roleStats
                ) >> r
          case consequence of
            ActionOK   ()  ->
              update (roleEventStats role) $
              (if haltWhenOK then halt else return) updateRole
            ActionHalt     ->
              update (roleEventStats role) $ return updateRole
            ActionCancel   -> do
              let updatedRole = (thingLens .~ Nothing) role
              update (roleEventStats updatedRole) $ halt $ ActionOK updatedRole
            ActionFail msg ->
              -- Returning a failure tells 'reactEventRegistry' to delete this role, so we update the
              -- statistics with an mempty (i.e. deleted) 'ActorEventHandlerStats' value.
              update mempty $ return $ ActionFail msg
    )
    registry
    mempty
  ) >>=
  modifying sceneStats . (<>)

-- | Not for export
--
-- With the given @event@, call the 'EventAction' taken by the given 'Lens', in order of most
-- recently added to least recently added, for each 'Actor's in the current 'Act'. Stop calling
-- 'EventActions' after the first 'EventAction' to return a 'pure' or 'empty' consequence. 
triggerEventHandlers
  :: (Monad m, MonadState Scene m)
  => (forall a . IO a -> m a)
  -> (forall a model
      . Script model a
      -> Actor
      -> Role model
      -> m (Consequence a, Maybe (Role model))
     )
  -> Lens' (Role Actor) (Maybe (EventAction event Actor))
  -> event
  -> m ()
triggerEventHandlers liftIO liftScript handler event =
  forActorsInRegistry False True liftIO handler $ \ role action ->
  liftScript (runEventAction action event) (theRoleModel role) role

guiTriggerEventHandlers
  :: Lens' (Role Actor) (Maybe (EventAction event Actor))
  -> event
  -> GUI provider Scene ()
guiTriggerEventHandlers = triggerEventHandlers liftIO guiInterpretScriptRole

-- | A GUI action to force the redraw of all elements in a Scene, regardless of whether they lie
-- within the updated clip region, or whether they have requested a redraw. This operation will slow
-- down your application if used more often. Use 'sceneRedraw' to do a more efficient redraw.
forceSceneRedraw
  :: (HappletWindow provider render, Happlet2DGraphics render)
  => GUI provider Scene ()
forceSceneRedraw =
  use sceneRegistry >>= \ registry ->
  reactEventRegistryIO True
    (\ _halt role0 -> do
        let role = role0 &
              actionDraw %~ maybe id const (role0 ^. actionRedraw) &
              actionRedraw .~ Nothing
        lift $ onCanvas $ draw2D mempty (role ^. actionDraw)
        -- TODO ^ Skip if clipRect does not intersects with 'theBoundingBox' of 'actionDraw'?
        modify $ (<> (roleEventStats role))
        return $ maybe empty (const $ pure role) (role0 ^. actionRedraw)
    )
    registry mempty >>=
  assign sceneStats

-- | Redraw all elements that have changed. Each element is erased (by redrawing all elements below
-- it that intersect with it's bounding box), and then redrawn.
sceneRedraw
  :: (HappletWindow provider render, Happlet2DGraphics render)
  => GUI provider Scene ()
sceneRedraw = do
  registry <- use sceneRegistry
  -- first scan the registry for 'Actor's that need to be erased
  eraseRegion <- canonicalize2DShape . uncurry rect2DUnion <$>
    reactEventRegistryIO True
    (\ _halt role -> do
       modify $ \ (stack, count) -> case role ^. actionRedraw of
         Nothing -> (stack, count)
         Just {} -> (theBoundingBox (role ^. actionDraw) : stack, seq count $! count + 1)
       return empty
    )
    registry
    ([], 0)
  -- now redraw
  unless (rect2DUnionNull eraseRegion) $
    reactEventRegistryIO True
    (\ _halt role0 -> case role0 ^. actionRedraw of
      Nothing -> do
        lift $ onCanvas $ draw2D eraseRegion $ role0 ^. actionDraw
        return empty
      Just newDraw -> do
        lift $ onCanvas $ draw2D eraseRegion newDraw
        let role = role0 & actionDraw .~ newDraw & actionRedraw .~ Nothing
        modify $ (<> (roleEventStats role))
        return $ pure role
    )
    registry
    mempty >>=
    assign sceneStats

-- | Like 'liftIO' but only works in a the 'GUI' monad for an 'Act' data structure.
actLiftIO :: (Act -> IO a) -> GUI provider Act a
actLiftIO = (get >>=) . (liftIO .)

-- | Use this function to initialize a new 'Act'. This function is of type 'Initialize' so it can
-- only be used at initialization time. It takes an initial model of any value (type variable
-- @init@), creates a 'Scene', and uses the given 'Script' function to initialize the scene.
newActHapplet
  :: init
  -> Script init ()
  -> Initialize provider (Happlet Act)
newActHapplet init f = newHappletIO $ do
  -- TODO: Consider whether a 'newActHapplet' should not take an arbitrary @init@ type, rather it
  -- should perhaps evaluate an initializer script of type (Script Scene ()).
  scene <- makeEmptyScene 16
  now   <- getCurrentTime
  let act st = Act
        { theActCurrentScene     = theScriptScene st
        , theCurrentMouseStatus  = MouseReady
        , theLatestMouseTime     = now
        , theCurrentDragItem     = Nothing
        , thePreviousMouseEvent  = Nothing
        , theLatestMouseEvent    = Nothing
        , theActHandleRightClick = const $ pure ()
        }
  let ir = role init
  actor <- makeActor ir
  runScript f
    ( ScriptState
      { theScriptRole        = ir
      , theScriptActor       = theUntypedActor actor
      , theScriptScene       = scene
      , theScriptRoleUpdated = False
      }
    ) >>= \ case
    (ActionFail err, _ ) -> error $ "app initializer failed: " ++ show err
    (ActionCancel  , st) -> return $ act st
    (ActionHalt    , st) -> return $ act st
    (ActionOK   () , st) -> return $ act st

-- | Use this function with the 'attachWindow' function and the result of 'newActHapplet' to create
-- the OS window.
actWindow
  :: ( CanMouse provider, CanKeyboard provider, CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     )
  => PixSize -> GUI provider Act ()
actWindow _initSize = resetEventHandlers

----------------------------------------------------------------------------------------------------

-- Event handler resets

actResetMouseEvents
  :: ( CanAnimate provider, CanMouse provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     )
  => GUI provider Act ()
actResetMouseEvents =
  theSceneStats <$> use actCurrentScene >>= \ stats ->
  let has f = f stats > 0 in
  let react which = mouseEvents which actMouseHandler in
  if has countActionMouseOver then react MouseAll
  else if has countActionMouseDrag then react MouseDrag
  else if has countActionClick || has countActionDoubleClick then react MouseButton
  else mouseEvents MouseAll $ const cancel

actResetKeyboardEvents :: CanKeyboard provider => GUI provider Scene ()
actResetKeyboardEvents = do
  keyboard <- maybe False (const True) <$> gets theSceneFocus
  keyboardEvents $ if keyboard then sceneKeyboardHandler else const cancel

actResetAnimationEvents
  :: ( CanAnimate provider, HappletWindow provider render
     , Managed provider, Happlet2DGraphics render
     )
  => GUI provider Act ()
actResetAnimationEvents =
  theSceneStats <$> use actCurrentScene >>= \ stats ->
  stepFrameEvents $
  if countActionAnimation stats > 0 then actAnimationHandler else const cancel

resetEventHandlers
  :: ( CanMouse provider, CanKeyboard provider, CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     )
  => GUI provider Act ()
resetEventHandlers = do
  actResetMouseEvents
  onScene actResetKeyboardEvents
  actResetAnimationEvents

----------------------------------------------------------------------------------------------------

-- Keyboard handler

-- | Force a 'Keyboard' event to occur in the current 'Act'.
sceneKeyboardHandler :: Keyboard -> GUI provider Scene ()
sceneKeyboardHandler evt = case evt of
  Keyboard True _ _ -> run evt
  RawKey   True _ _ -> run evt
  _                 -> return ()
  where
  run evt =
    use sceneFocus >>= \ case
      Nothing                -> return ()
      Just actor@(Actor ref) ->
        liftIO (readIORef ref) >>= \ role ->
        case theActionKeyboard role of
          Nothing     -> return ()
          Just script ->
            guiInterpretScriptRole (runEventAction script evt) actor role >>= \ (result, role) ->
            let keepFocus = sceneFocus .= (theRoleModel <$> role) in
            let unfocus = sceneFocus .= Nothing in
            case result of
              ActionOK ()    -> keepFocus >> return ()
              ActionHalt     -> keepFocus >> empty
              ActionCancel   -> unfocus >> cancel
              ActionFail msg -> unfocus >> throwError msg

----------------------------------------------------------------------------------------------------

-- Animation handler

-- | Force an animation step event to occur in the current 'Act'.
actAnimationHandler
  :: (HappletWindow provider render, Managed provider, Happlet2DGraphics render)
  => UTCTime -> GUI provider Act ()
actAnimationHandler t0 = do
  -- If there is an animation handler in effect, mouse actions are stored in 'actNextMouseAction' so
  -- that they may be delayed until the next animation frame event, to ensure mouse events are
  -- synchronized with animation frame events.
  actActualMouseHandler
  onScene $ guiTriggerEventHandlers actionAnimation t0

----------------------------------------------------------------------------------------------------

-- Mouse events

data MouseStatus
  = MouseReady
    -- ^ No events have happend yet, or the last event was executed and we are awaiting incoming
    -- events.
  | MouseMoved
    -- ^ Mouse movement without button click occurred.
  | Mouse1stDown
    -- ^ Mouse button pressed down. This should trigger a click event.
  | Mouse1stUp
    -- ^ Mouse button released after being pressed down.
  | MouseDragged
    -- ^ Mouse button moved while button still down after 1st or 2nd mouse down.
  deriving (Eq, Ord, Show, Enum)

-- | The 'actMouseHandler' has some pretty complex logic in order to make sure the mouse user
-- experience is very consistent across all apps built with the "Happlets.Actor" API.
--
-- Left clicks are de-bounced and timed so that single-click and double-click events can be decoded
-- from the click stream and translated into calls to 'sceneClick' and 'sceneDoubleClick'.
--
-- All other mouse actions are checked whether they are button-down or button-up events, and if they
-- are "button-down" (leading edge triggered), the mouse event is sent as it is to the 'actClick'
-- function for all 'Actor's in the 'Scene'.
actMouseHandler
  :: ( CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     )
  => Mouse -> GUI provider Act ()
actMouseHandler new =
  -- TODO: certain constant values have been hard-coded into this function, like the double-click
  -- distance, and the minimum time required to elapse between events for the event to not be
  -- considered a "bounce". These hard-coded values should be taken from a global configuration
  -- variable.
  let minDelayBetweenEvents = 1/16 in
  use actLatestMouseTime >>= \ past ->
  liftIO getCurrentTime >>= \ present ->
  use actLatestMouseEvent >>= \ old ->
  if maybe False (similarMouseEvents new) old &&
     diffUTCTime present past < minDelayBetweenEvents
  then actLatestMouseEvent .= Just new
  else
    use actLatestMouseEvent >>= assign actPreviousMouseEvent >>
    actLatestMouseEvent .= Just new >>
    actLatestMouseTime .= present >>
    stepFrameEvents actAnimationHandler

-- Mouse events that can happen:
-- 1. First down -> set latest event
-- 2. Anomalous close before time-in -> push latest to previous, ignore all but latest
-- 3. Anomalous close after time-in -> ignore any but mouse up, an up generates click + push to previous
-- 4. Anomalous far before time-in -> if down, clear prior state, set new latest event
-- 5. Second down close after time-in -> update state, set latest event
-- 6. Second down far after time-in -> set state to drag event

-- | This is the function that actually executes the mouse action. The mouse action is taken from
-- the 'Act' state field 'theNextMouseAction'.
actActualMouseHandler
  :: (HappletWindow provider render, Managed provider, Happlet2DGraphics render)
  => GUI provider Act ()
actActualMouseHandler =
  liftIO getCurrentTime >>= \ t ->
  use actLatestMouseTime >>= \ t0 ->
  actLatestMouseTime .= t >>
  if diffUTCTime t t0 < 1.0 / 16.0 then return ()
    -- If mouse events occur too close together temporally, simply return without modifying the
    -- mouse state. This will result in the latest mouse event being over-written by the next event
    -- mouse event, but if no next mouse event occurs, this event handler will still be triggered on
    -- the next animation step (since the animation handler is always active while mouse events are
    -- pending) and the latest mouse event will have a chance to be processed then.
  else
  use actLatestMouseEvent >>= \ case
    Nothing -> return ()
    Just new@(Mouse _devID newPressed _newModBits _newButton _newPoint) ->
      use actCurrentMouseStatus >>= \ stat ->
      use actPreviousMouseEvent >>= \ old ->
      let step0 state = do
            actLatestMouseEvent   .= Nothing
            actPreviousMouseEvent .= Just new
            actCurrentMouseStatus .= state
          step state = step0 state >> actCurrentDragItem .= Nothing
          drag = step0 MouseDragged -- like 'step' but doesnt clear the current drag item
      in
      let firstAction = if newPressed then step Mouse1stDown else step MouseMoved in
      case old of
        Nothing -> firstAction
        Just old@(Mouse _devID _oldPressed _oldModBits _oldButton _oldPoint) ->
          let thresh = 8 in -- TODO: make this threshold configurable
          let dist = mouseEventDistance new old in
          case stat of
            MouseReady   -> firstAction
            MouseMoved   ->
              if newPressed
              then step Mouse1stDown
              else step MouseMoved >> onScene (sceneMouseDrag new)
            Mouse1stDown ->
              if newPressed then
                if dist > thresh
                then drag >> onScene (sceneMouseDrag new)
                else step Mouse1stDown
              else step Mouse1stUp >> onScene (sceneClick new)
            Mouse1stUp   ->
              if newPressed
              then step MouseReady >> onScene (sceneDoubleClick new)
              else step MouseMoved >> onScene (sceneMouseOver new)
            MouseDragged ->
              if newPressed
              then onScene (sceneMouseDrag new)
              else step MouseMoved >> onScene (sceneMouseOver new)

-- | Force a 'Mouse' action button click event to occur in the current 'Act'.
sceneClick :: Mouse -> GUI provider Scene ()
sceneClick = guiTriggerEventHandlers actionClick

-- | Force a 'Mouse' context menu button click event to occur in the current 'Act'.
actRightClick :: Mouse -> GUI provider Scene ()
actRightClick = guiTriggerEventHandlers actionRightClick

-- | Force a 'Mouse' action button double click event to occur in the current 'Act'.
sceneDoubleClick :: Mouse -> GUI provider Scene ()
sceneDoubleClick = guiTriggerEventHandlers actionDoubleClick

-- | Force a 'Mouse'-over event to occur in the current 'Act'.
sceneMouseOver
  :: (HappletWindow provider render, Managed provider, Happlet2DGraphics render)
  => Mouse -> GUI provider Scene ()
sceneMouseOver = guiTriggerEventHandlers actionMouseOver

-- | Force a 'Mouse' drag event to occur in the current 'Act'.
sceneMouseDrag
  :: (HappletWindow provider render, Managed provider, Happlet2DGraphics render)
  => Mouse -> GUI provider Scene ()
sceneMouseDrag = guiTriggerEventHandlers actionMouseDrag
