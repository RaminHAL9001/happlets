-- | This module provides an 'Act', 'Scene', and 'Actor' data types, and the 'Script' function
-- type. Every 'Act' contains a current 'Scene', a 'Script' function type can alter the current
-- 'Scene' of an 'Act' by instructing 'Actor's how to behave. The 'Act' data type is a Happlet that
-- can automatically sets it's own Happlet event handlers based on the needs of the 'Actor's in the
-- current 'Scene'.
--
-- 'Actor' data types have their own internal state values which can only be modified by 'Script'
-- functions. 'Actor's have callbacks for virtual event handlers which are generated by the 'Act' in
-- response to low-level Happlet events. The 'Actor' event callbacks are slightly different from
-- that of the 'Happlet' event handlers, for example, actions for left, right, and double-click
-- mouse actions can be set for each 'Actor' are provided, unlike a 'Happlet' which does not provide
-- a double-click event handler, and which does not provide separate actions for left and right
-- clicks. 'Actor' event handlers also use callback functions of type 'Script', and __not__ of type
-- 'GUI' as a low-level Happlet would.
--
-- 'Act' data values are usually not manipulated directly, they are the @model@ type used by the
-- 'GUI' monad. 'Act's are initialized by 'newActHapplet' and initialized with a function of type
-- 'Script' which places various 'Actors' in their "first positions" (initial states) into the
-- current 'Scene' of the 'Act'. The 'Act' itself handles it's own low-level Happlet events based on
-- the event handlers in use by all 'Actor's in it's current 'Scene'.
module Happlets.Scene
  ( -- ** Acts
    Act, actWindow, newActHapplet, actLiftIO,
    -- ** Scenes
    Scene, newScene, sceneBracket, grabFocus, delegateSceneEvents, debugEventHandlerStats,
    -- *** Selecting Actors in a Scene
    ActorSelect, ActorInfo(..), selectInScene,
    -- ** The Actor data type
    Actor, TypedActor, theUntypedActor, actor, actress, onStage, selfLabel, actorTypedActor,
    -- ** The Script function type
    Script, scriptWithActor,
    -- ** Event Handlers
    OnQueue, onDraw, scriptRedraw, onSelect, onKeyboard, onAnimate,
    onMouseOver, onMouseDown, onMouseClick, onMouseDoubleClick, onMouseDrag,
    -- *** Event Types
    Mouse2D(..), PixelMouse, MouseButton(..), mouse2DPosition, mouse2DModifiers,
    module Happlets.Control.Keyboard,
    -- *** Event Handler Types
    EventAction(..), runEventAction,
    -- *** Sending and Delegating Events
    --
    -- These functions trigger an event handler for the current 'Actor' in the current 'Script'
    -- context using event data that you can synthesize yourself, or capture from another event and
    -- delegate. These functions are only of any use for event handlers that need to execute some
    -- sort of computation, so there are no redraw triggers -- because redrawing only changes the
    -- 'Drawing' data structure for the current 'Actor' it doesn't execute a computation.
    actorAnimate, actorKeyboard,
    actorMouseOver, actorDown, actorClick, actorDoubleClick, actorDrag,
    -- *** Actor Event Handler Accounting
    ActorEventHandlerStats(..), MouseEventHandlerStats(..), getEventHandlerStats,
    -- ** Low-Level Happlets APIs
    guiRunScriptTypedActor, guiRunScriptActor, sceneRedraw, forceSceneRedraw,
    sceneKeyboardHandler, actAnimationHandler,
    sceneMouseDown, sceneMouseClick, sceneMouseDoubleClick,
    sceneMouseOver, sceneMouseDrag,
  ) where

import           Happlets.Logging
                 ( CanWriteReports(report), LogReporter,
                   ReportLevel(DEBUG, ERROR)
                 )
import           Happlets.Initialize (Initialize, newHappletIO)
import           Happlets.Model.GUI
                 ( GUI, Happlet, ProvidesLogReporter, onSubModel
                 )
import           Happlets.Model.Registry
                 ( Registry, newRegistry, registryEnqueue,
                   reactEventRegistry, reactEventRegistryIO
                 )
import           Happlets.View
                 ( Happlet2DGraphics(draw2D),
                   HappletWindow(onCanvas),
                   Sized2DRaster(getViewSize),
                   Has2DOrigin(origin2D)
                 )
import           Happlets.View.Types2D
                 ( SampCoord, PixSize, Point2D,
                   Rect2D, rect2D, rect2DSize, rect2DHead,
                   Drawing, drawingIsNull, canonicalize2DShape,
                   rect2DUnion, rect2DUnionNull, theBoundingBox,
                 )
import           Happlets.Control.Animate (CanAnimate(stepFrameEvents))
import           Happlets.Control.Consequence
                 ( Consequential(cancel), CatchConsequence(catchConsequence),
                   Consequence(..), ConsequenceT(..), runConsequenceT
                 )
import           Happlets.Control.Mouse
                 ( CanMouse(mouseSignals), MouseSignal(..),
                   MouseSignalPattern(MouseButton, MouseDrag, MouseAll),
                   MouseButtonSignal(MotionOnly,LeftClick,RightClick),
                   similarMouseSignals, mouseSignalDistance
                 )
import           Happlets.Control.Keyboard
                 ( CanKeyboard(keyboardEvents),
                   Keyboard(Keyboard, RawKey),
                   ModifierBits
                 )
import           Happlets.Control.WindowManager

import           Control.Applicative (Alternative(..))
import           Control.Lens
                 ( ALens', Lens', lens, cloneLens, view, set, use, assign, modifying,
                   (&), (^.), (%~), (.~), (<>~), (.=), (%=)
                 )
import           Control.Monad (MonadPlus(..), guard, when, unless, (>=>))
import           Control.Monad.Except (MonadError(throwError, catchError))
import           Control.Monad.Fail (MonadFail(fail))
import           Control.Monad.IO.Class (MonadIO(..))
import           Control.Monad.Reader (MonadReader(..), ReaderT(..))
import           Control.Monad.State
                 ( MonadState(state, get), StateT(..),
                   gets, modify, runStateT
                 )
import           Control.Monad.Trans (MonadTrans(..))

--import           Data.Functor.Const         (Const(..))
import           Data.IORef (IORef, newIORef, readIORef, writeIORef)
import qualified Data.Text as Strict
import           Data.Time.Clock (UTCTime, getCurrentTime, diffUTCTime)

import           System.IO (hPutStrLn, stderr)

----------------------------------------------------------------------------------------------------

-- | The 'Script' function type is a procedure (a script) that defines the behavior of an 'Actor'
-- while is active in a 'Scene'. The 'Script' operates on a 'TypedActor' containing @model@ state
-- data, and so the 'Script' @model@ type will always be the same as the 'TypedActor's @model@ type.
--
-- The 'Script' function type is monadic and instantiates 'MonadState' so that the @model@ data
-- can be inspected and updated using the ordinary 'get', 'put', 'modify', and 'state' functions.
--
-- There are also several APIs defined below, many of which begin with the name "self", which are
-- used to alter the event handlers of the 'TypedActor' that the 'Script' is currently operating on.
--
-- 'Script' instantiates the 'CancelableAction' function, so you can evaluate 'cancel' somwhere in
-- the 'Script' to indicate that this particular event should no longer be reacted to by an 'Actor'.
--
-- The 'Script' function type also instantiates 'Sized2DRaster', so it is possible to use
-- 'getViewSize' and use this information to render 'Drawing's to within a particular area.
newtype Script model a
  = Script{ unwrapScript :: ConsequenceT (StateT (ScriptState model) IO) a }
  deriving Functor -- NOT deriving MonadIO

data ScriptState model
  = ScriptState
    { theScriptRole        :: !(Role model) -- ^ The model currently being updated.
    , theScriptActor       :: !(TypedActor model)
      -- ^ If the 'TypedActor' that is currently executing this script has been staged in a 'Scene',
      -- this value will contain the 'Actor' reference.
    , theScriptScene       :: !Scene -- ^ Access to the 'Scene'.
    , theScriptRoleUpdated :: !Bool
      -- ^ Records whether event handlers (and only event handlers) in 'theScriptRole' have been
      -- modified.
    }

instance Applicative (Script model) where
  pure = Script . pure
  (Script f) <*> (Script a) = Script $ f <*> a

instance Monad (Script model) where
  return = pure
  (Script a) >>= f = Script $ a >>= unwrapScript . f

instance MonadState model (Script model) where
  state f = Script $ do
    (a, widget) <- fmap f $ lift $  use $ scriptRole . roleModel
    lift $ scriptRole . roleModel .= widget
    return a

instance MonadError Strict.Text (Script model) where
  throwError = Script . throwError
  catchError (Script try) catch = Script $ catchError try $ unwrapScript . catch

instance MonadFail (Script model) where { fail = throwError . Strict.pack; }

instance Alternative (Script model) where
  empty = Script empty
  (Script a) <|> (Script b) = Script $ a <|> b

instance MonadPlus (Script model) where { mzero = empty; mplus = (<|>); }

instance Consequential (Script model) where { cancel = Script cancel; }

instance CatchConsequence (Script model) where
  catchConsequence (Script (ConsequenceT f)) =
    Script . ConsequenceT . StateT $
    runStateT f >=> \ (result, st) ->
    pure (pure result, st)

instance Monoid a => Semigroup (Script model a) where
  a <> b = mappend <$> (a <|> pure mempty) <*> (b <|> pure mempty)

instance Monoid a => Monoid (Script model a) where
  mempty = pure mempty
  mappend = (<>)

instance Sized2DRaster (Script model) where
  getViewSize = scriptGetsScene $ rect2DSize . theSceneGlobalBounds

-- | Ask a 'TypedActor' to perform a 'Script', which updates the @model@ of a 'TypedActor'. Returns
-- a value indicating whether the internals of the 'TypedActor' (either the @model@ or any of the
-- event handlers) have changed. This does not update the 'ActorEventHandlerStats' within the
-- 'Scene' because the 'TypedActor' need not be a member of the current 'Scene'.
runScript :: Script model a -> Scene -> TypedActor model -> IO (Consequence a, ScriptState model)
runScript (Script f) scene actor@(TypedActor{theUntypedActor=(Actor untyped)}) = do
  -- Note that we do not update the 'ActorEventHandlerStats' of the 'Scene' because there is no
  -- guarantee that the 'TypedActor' on which we are evaluating the 'Script' is actually part of the
  -- 'Scene' or not.
  role0 <- readIORef (theTypedActorRole actor)
  (result, st) <- runStateT (runConsequenceT f) ScriptState
    { theScriptRole  = role0
    , theScriptActor = actor
    , theScriptScene = scene
    , theScriptRoleUpdated = False
    } 
  when (theScriptRoleUpdated st) $ do
    let role  = theScriptRole st
    writeIORef (theTypedActorRole actor) role
    writeIORef untyped $ encloseRole actor role
  return (result, st)

debugEventHandlerStats :: Strict.Text -> Script model ()
debugEventHandlerStats message = do
  role <- scriptGets theScriptRole
  report DEBUG $ message <> "\n  Role:\n" <> theRoleLabel role <>
    "\n  Event handler stats:\n" <> Strict.pack (show $ roleEventStats role)

-- | not for export
scriptIO :: IO a -> Script model a
scriptIO = Script . liftIO

-- | not for export
scriptGets :: (ScriptState model -> a) -> Script model a
scriptGets = Script . lift . gets

scriptModify :: (ScriptState model -> ScriptState model) -> Script model ()
scriptModify = Script . lift . modify

scriptGetsRole :: (Role model -> a) -> Script model a
scriptGetsRole = scriptGets . (. theScriptRole)

scriptGetsScene :: (Scene -> a) -> Script model a
scriptGetsScene = scriptGets . (. theScriptScene)

-- | Access to the @model@ that is being updated by this 'Script'.
scriptRole :: Lens' (ScriptState model) (Role model)
scriptRole = lens theScriptRole $ \ a b -> a{ theScriptRole = b, theScriptRoleUpdated = True }

-- | Access to the 'Scene' in which this script is being recited.
scriptScene :: Lens' (ScriptState model) Scene
scriptScene = lens theScriptScene $ \ a b -> a{ theScriptScene = b }

-- | A 'TypedActor' allows you to assign an arbitrary text string to it called a "label". This text
-- string can be used for any reason at all, it need not be unique. It is usually used to provide
-- some kind of information to end users about the 'Actor', like what it is and where it originated,
-- or perhaps even the code that constructed it.
--
-- Provide a function for modifying the description, the modified description is returned. Evaluate
-- @('selfDescribe' 'id')@ to retrieve the description without modifying it.
selfLabel :: (Strict.Text -> Strict.Text) -> Script model Strict.Text
selfLabel f = scriptModify (scriptRole . roleLabel %~ f) >> scriptGetsRole theRoleLabel

-- | This function hands control over to another 'TypedActor' to act out another 'Script' function,
-- then returns control to the current 'Script' and 'TypedActor'. Any modifications made to the
-- 'Scene' by the other actor will persist as control is passed back and forth -- for example if the
-- other actor changes 'theSceneFocus' or evaluates 'actor' or 'actress' to bring still other actors
-- into the 'Scene', these changes will persist after this other actor completes acting out their
-- 'Script' control comes back to the current 'Actor' acting out the current script. Returns the
-- 'Consequence' of the @'Script' other@ evaluation.
--
-- It is possible for a 'TypedActor' to contain a 'Scene'. After evaluating this function on a value
-- of @'TypedActor' 'Scene'@, it is necessary to call 'delegateSceneEvents' as the final action of
-- the 'Script' to ensure events captured by the 'Scene' are delegated to the 'TypedActor's to which
-- it refers.
--
-- Also note that the changes made to a 'TypedActor' will also be visible to it's associated untyped
-- 'Actor', but will not actually modify the untyped 'Actor'.
--
-- See also: 'guiInterpretScript', 'delegateSceneEvents'.
scriptWithTypedActor
  :: Script other a
  -> TypedActor other
  -> Script model a
scriptWithTypedActor f ref =
  -- Persist changes to the 'Scene' by the other actor across hand-off of control back to the
  -- current 'Script' context.
  Script . ConsequenceT . StateT $ \ st0 ->
  runScript f (theScriptScene st0) ref >>= \ (result, st) -> pure
  ( result
  , st0
    { theScriptScene = theScriptScene st
    , theScriptRoleUpdated = theScriptRoleUpdated st
    }
  )

-- | Evaluates the continuation 'Script' (the first argument) via the untyped 'Actor' by evaluating
-- 'scriptWithTypedActor' on an 'actorEventActor' of the 'Actor'. When evaluating 'runScene' on a ,
-- if 'Actor' in this way, the 'runScript' function is actually evaluated twice. The first
-- invocation triggeres event handlers on the 'Actor', and this in turn invokes the event handlers
-- on the 'TypedActor'. The 'TypedActor' event handler updates both itself and the 'Actor's event
-- handlers and returns control to the first invocation on 'Actor'. If the continuation 'Script'
-- makes __any__ update to it's own model or event handlers, these updates will be silently
-- discarded because they are triggering updates on an out-of-date copy of the 'Actor's state.
--
-- See also: 'guiInterpretScript', 'delegateSceneEvents'.
scriptWithActor :: Script Actor a -> Actor -> Script model a
scriptWithActor f =
  scriptWithTypedActor
  ( f <*
    scriptModify (scriptRoleUpdated .~ False)
    -- Force updates on the 'TypedActor Actor' to be ignored.
  ) . actorTypedActor

-- | Steals the spotlight -- meaning it becomes the target non-mouse events such as keyboard
-- events. This function can be evaluated within the event handler for an 'Actor', it will change
-- the 'sceneFocus' of the current 'Scene' to be the 'Actor' that evaluates this function.
grabFocus :: Script model ()
grabFocus =
  scriptGets (theUntypedActor . theScriptActor) >>=
  scriptModify . set (scriptScene . sceneFocus) . Just

----------------------------------------------------------------------------------------------------

-- | While not an 'OnQueue' function, this function can be used to queue a drawing operation for the
-- 'TypedActor' for the current @model@ that is being 'Script'ed. See also the 'scriptRedraw'
-- function, which lets you update the existing 'Drawing' for the current 'TypedActor'.
onDraw :: Drawing SampCoord -> Script model ()
onDraw = scriptModify . set (scriptRole . actionRedraw) . Just

-- | This function accomplishes the same thing as 'onDraw', but allows you to directly manipulate
-- the drawing function that is currently set for the current 'TypedActor'.
scriptRedraw :: (Drawing SampCoord -> Drawing SampCoord) -> Script model ()
scriptRedraw redraw = scriptModify $
  scriptRole %~ \ role -> role &
  actionRedraw .~ Just (redraw $ maybe (role ^. actionDraw) id $ role ^. actionRedraw)

-- | A function of type 'OnQueue' is an instruction to modify the behavior of a 'TypedActor', it
-- sets an 'EventAction' handler for a 'TypedActor'. All 'OnQueue' functions take a continuation
-- function that takes the currently installed 'EventAction' handler function (if any) and returns a
-- new 'EventAction' handler which may or may not evaluate the currently installed function as part
-- of it's behavior.
--
-- An 'OnQueue' function evaluates to a 'Script' type, so any function of type 'OnQueue' can be used
-- within the context of a 'Script', as long as you pass to the 'OnQueue' a continuation function of
-- the expected type.
type OnQueue event model =
      (Maybe (EventAction event model) -> EventAction event model) -> Script model ()

-- | not for export
--
-- A function that constructs an 'OnQueue' function.
onQueue :: Lens' (Role model) (Maybe (EventAction event model)) -> OnQueue event model
onQueue handle f = do
  scriptModify $
    (scriptRoleUpdated .~ True) .
    (scriptRole . cloneLens handle %~ Just . f)
  stats <- scriptGetsScene theSceneStats
  role  <- scriptGets theScriptRole
  report DEBUG $ Strict.pack $
    "Updated event handlers for " ++
    show (theRoleLabel role) ++ ":\n" ++
    show stats

-- | Alter the selection behavior of the 'TypedActor'.
--
-- Any object that responds to clicks needs a function to decide whether the click lands on the
-- selectable portion of the 'Role's visualization, this field sets that function.
--
-- 'Role's are required to separate the logic that determines whether it's visualization is
-- selectable and the logic that decides whether the 'Role' responds to an event. To enforce this
-- rule, if a 'Role's 'actionSelect' is 'Nothing', or is a 'Script' that evaluates to 'empty', the
-- 'Role' will not be passed any events. A 'Script' that evaluates to @('pure' ())@ indicates that
-- the mouse event can select the 'Role'.
--
-- Of course, you can make a 'Role' receive focus programmatically, in which case it can respond to
-- keyboard events.
onSelect :: OnQueue SampCoord model
onSelect = onQueue actionSelect

-- | Alter the keyboard event handler function.
onKeyboard :: OnQueue Keyboard model
onKeyboard = onQueue actionKeyboard

-- | Mouse-over events are events that occur when the mouse moves, but none of the mouse buttons are
-- depressed.
onMouseOver ::OnQueue PixelMouse model
onMouseOver = onQueue actionMouseOver

-- | Set an event handler for a leading-edge mouse-down event. A mouse down an event triggered as
-- soon as the button press is detected. It is different from an 'onMouseClick' event which is
-- triggered after one complete mouse down event and one complete mouse up event. One example of
-- where an 'onMouseDown' event is useful would be for a file manager which selects files with mouse
-- down events. Usually a mouse down immediately highlights the item under the mouse cursor, while a
-- second mouse down (see 'onMouseDoubleClick') triggers an open file action on the item.
--
-- Specify the left or right mouse button that that should trigger the event handler continuation
-- supplied as the second argument.
onMouseDown :: MouseButton -> OnQueue PixelMouse model
onMouseDown button = onQueue $ cloneLens (actionMouseDown button)

-- | Set an event handler for a trailing-edge mouse-down event. A mouse click is a mouse-down event
-- followed by a mouse-up event, the action is triggered as soon as the mouse-up event is
-- received. One example of where an event like this is useful would be for a push button, which are
-- usually highlighted on a mouse-down event, and triggered on a mouse-up event.
--
-- Specify the left or right mouse button that that should trigger the event handler continuation
-- supplied as the second argument.
onMouseClick :: MouseButton -> OnQueue PixelMouse model
onMouseClick button = onQueue $ cloneLens (actionMouseClick button)

-- | Set an event handler for a double-click mouse event. A double click is a mouse-down event,
-- followed by a mouse up event, followed by another mouse down event. The event handler is
-- triggered on the second mouse down event.
onMouseDoubleClick :: MouseButton -> OnQueue PixelMouse model
onMouseDoubleClick button = onQueue $ cloneLens (actionMouseDouble button)

-- | Set an event handler for a mouse drag event. A drag event is a mouse down event followed by a
-- mouse-over event. Every mouse-over event triggers the drag event handler. When a mouse-up event
-- is received, the event handler is triggered one final time with 'Nothing' as the event data.
onMouseDrag :: MouseButton -> OnQueue (Maybe PixelMouse) model
onMouseDrag button = onQueue $ cloneLens (actionMouseDrag button)

-- | If any 'TypedActor' in a 'Scene' has an animation type event handler set, an animation event
-- loop is enabled, and animation frame step events are broadcast to all 'TypedActor's who have set
-- this event handler, repeatedly and at very fast regular intervals.
onAnimate :: OnQueue UTCTime model
onAnimate = onQueue actionAnimation

-- | Set to 'True' if any part of the 'scriptRole' is changed.
scriptRoleUpdated :: Lens' (ScriptState model) Bool
scriptRoleUpdated = lens theScriptRoleUpdated $ \ a b -> a{ theScriptRoleUpdated = b }

---- | Use a lens to modify something in the 'Scene'
--scriptModifyScene :: Lens' Scene thing -> (thing -> IO thing) -> Script any ()
--scriptModifyScene lens f = Script $ lift $
--  use (scriptScene . cloneLens lens) >>=
--  liftIO . f >>=
--  assign (scriptScene . cloneLens lens)

----------------------------------------------------------------------------------------------------

-- | A 'Role' contains some arbitrary typed @model@ data, and a set of event handlers that can
-- operate on this data.
--
-- In object oriented programming terms, this data type is more of a class than an object that
-- intantiates the class. The 'actor' and 'actress' functions creates an instance of the class
-- within a 'Scene'.
data Role model
  = Role
    { theRoleModel         :: !model
    , theRoleLabel         :: !Strict.Text
    , theActionDraw        :: !(Drawing SampCoord)
    , theActionRedraw      :: !(Maybe (Drawing SampCoord))
    , theActionSelect      :: !(Maybe (EventAction SampCoord model))
    , theActionKeyboard    :: !(Maybe (EventAction Keyboard model))
    , theActionMouseOver   :: !(Maybe (EventAction PixelMouse model))
      -- ^ Mouse over event with no mouse buttons depressed
    , theActionRightMouse  :: !(Maybe (RoleMouseEvents model))
      -- ^ Event handlers for the right mouse button
    , theActionLeftMouse   :: !(Maybe (RoleMouseEvents model))
      -- ^ Event handlers for the left mouse button
    , theActionAnimation   :: !(Maybe (EventAction UTCTime model))
    }

-- | A cluster of event handlers that can respond to either left or right mouse buttons. Each mouse
-- button has it's own FSM state and so can respond to events independently from one another, which
-- is why there needs to be two identical sets of event handlers.
data RoleMouseEvents model
  = RoleMouseEvents
    { theActionMouseDown    :: !(Maybe (EventAction PixelMouse model))
      -- ^ Action triggered on mouse button leading-edge click, that is, as soon as a mouse-down
      -- event occurs, the handler is triggered without waiting for a mouse-up event. An example of
      -- this is in a file browser, clicking down on a file immediately selects the file without
      -- waiting for a mouse-up event.
    , theActionMouseClick   :: !(Maybe (EventAction PixelMouse model))
      -- ^ Action triggered on mouse button trailing-edge click, that is, a complete mouse-down and
      -- mouse-up pair of events. An example of this is a push button which does not trigger it's
      -- event handler until a mouse-down and mouse-up event both occur within the visible button
      -- region.
    , theActionMouseDouble  :: !(Maybe (EventAction PixelMouse model))
      -- ^ Left mouse button double-click, triggered on second leading edge click if the mouse is
      -- not moved.
    , theActionMouseDrag    :: !(Maybe (EventAction (Maybe PixelMouse) model))
      -- ^ Left mouse button drag, ends when event is 'Nothing'. Event handler does not need to
      -- remove itself when drag ends.
    }

-- | Expresses information about which event handlers in a 'TypedActor' are set as an integer so
-- that the number of 'Role's that respond to a particular event type can be counted. This is used
-- to determine whether a group of 'Role's in a 'Scene' itself needs to maintain the event handler
-- in the 'Happlet' environment.
--
-- Some event handlers, for example 'theActionKeyboard' or 'theActionDoubleClick' are only triggered
-- if they have focus, i.e. the 'Scene' has the object set in 'theSceneFocus', these event handlers
-- do not need to be included in the stats. Only event handlers that are triggered by iterating over
-- all objects in a 'Scene' need to included in the stats data structure.
data ActorEventHandlerStats
  = ActorEventHandlerStats
    { countActors :: !Int
      -- ^ Does the actor exist? This is here to simply count the number of 'Actor's in a
      -- 'Scene'. It is zero only if this 'ActorEventHandlerStats' value is 'mempty'.
    , countActionDraw        :: !Int
      -- ^ Non-zero if an 'Actor' is drawn, meaning it can be drawn to the screen
    , countActionRedraw      :: !Int
      -- ^ Non-zero if an 'Actor' is to be redrawn
    , countActionSelect      :: !Int
      -- ^ Non-zero if an 'Actor' responds to selection actions
    , countActionKeyboard    :: !Int
      -- ^ Non-zero if an 'Actor' responds to 'Keyboard' actions
    , countActionMouseOver   :: !Int
      -- ^ Non-zero if an 'Actor' responds to mouse-over events.
    , countActionMouseRight  :: !(Maybe MouseEventHandlerStats)
      -- ^ Non-zero if an 'Actor' responds to any mouse button events.
    , countActionMouseLeft   :: !(Maybe MouseEventHandlerStats)
      -- ^ Non-zero if an 'Actor' responds to any mouse button events.
    , countActionAnimation   :: !Int
      -- ^ Non-zero if an 'Actor' responds to animation step events
    }

data MouseEventHandlerStats
  = MouseEventHandlerStats
    { countActionMouseDown   :: !Int
    , countActionMouseClick  :: !Int
    , countActionMouseDouble :: !Int
    , countActionMouseDrag   :: !Int
    }

instance Monoid ActorEventHandlerStats where
  mappend = (<>)
  mempty = ActorEventHandlerStats
    { countActors            = 0
    , countActionDraw        = 0
    , countActionRedraw      = 0
    , countActionSelect      = 0
    , countActionKeyboard    = 0
    , countActionMouseOver   = 0
    , countActionMouseRight  = mempty
    , countActionMouseLeft   = mempty
    , countActionAnimation   = 0
    }

instance Monoid MouseEventHandlerStats where
  mappend = (<>)
  mempty = MouseEventHandlerStats
    { countActionMouseDown   = 0
    , countActionMouseClick  = 0
    , countActionMouseDouble = 0
    , countActionMouseDrag   = 0
    }

instance Semigroup ActorEventHandlerStats where
  a <> b = let add f = f a + f b in ActorEventHandlerStats
    { countActors            = add countActors
    , countActionDraw        = add countActionDraw
    , countActionRedraw      = add countActionRedraw
    , countActionSelect      = add countActionSelect
    , countActionKeyboard    = add countActionKeyboard
    , countActionMouseOver   = add countActionMouseOver
    , countActionMouseRight  = countActionMouseRight a <> countActionMouseRight b
    , countActionMouseLeft   = countActionMouseLeft  a <> countActionMouseLeft  b
    , countActionAnimation   = add countActionAnimation
    }

instance Semigroup MouseEventHandlerStats where
  a <> b = let add f = f a + f b in MouseEventHandlerStats
    { countActionMouseDown   = add countActionMouseDown
    , countActionMouseClick  = add countActionMouseClick
    , countActionMouseDouble = add countActionMouseDouble
    , countActionMouseDrag   = add countActionMouseDrag
    }

instance Show ActorEventHandlerStats where
  show a =
    (\ case
      []    -> "    (no event handlers set)\n"
      elems -> unlines $ ("    " ++) <$> elems
    ) $
    filter (not . null) $
    let f str item = if item a == 0 then "" else str ++ " = " ++ show (item a) in
    [ f "           countActors" countActors
    , f "       countActionDraw" countActionDraw
    , f "     countActionRedraw" countActionRedraw
    , f "     countActionSelect" countActionSelect
    , f "  countActionAnimation" countActionAnimation
    , f "   countActionKeyboard" countActionKeyboard
    , f "  countActionMouseOver" countActionMouseOver
    , showMouseEventHandlerStats "countActionMouseRight" $ countActionMouseRight a
    , showMouseEventHandlerStats "countActionMouseLeft" $ countActionMouseLeft a
    ]

showMouseEventHandlerStats :: String -> Maybe MouseEventHandlerStats -> String
showMouseEventHandlerStats which = maybe "" $ \ a ->
  (\ case
      []    -> ""
      elems -> "  " ++ which ++ ":\n" ++ unlines (("       " ++) <$> elems)
  ) $
  filter (not . null) $
  let f str item = if item a == 0 then "" else str ++ " = " ++ show (item a) in
  [ f "countActionMouseDown" countActionMouseDown
  , f "countActionMouseClick" countActionMouseClick
  , f "countActionMouseDouble" countActionMouseDouble
  , f "countActionMouseDrag" countActionMouseDrag
  ]

-- | This is a mouse event type used within a 'Scene' and can be transformed according to a
-- 'Script'. It instantiates 'Functor' so that you can transform 'theMouse2DPosition' to a local
-- coordinate system (if need be) before passing it on to some even higher-level event handler.
--
-- A 'Mouse2D' event is different from the system level 'MouseSignal' event data type defined in
-- "Happlets.Control.Mouse". 'MouseSignal' is usually too low-level to be of much use to application
-- developers, it only provides whether the mouse buttons are depressed or not, the position,
-- keyboard modifiers, and device id, while it does not say anything about whether the mouse event
-- is a click, a double-click, a drag, or a hover. This is the problem that 'Script' solves with the
-- 'Mouse2D' data type, it gives you a way to react to these higher-level events without needing to
-- invent your own finite state mahcine (FSM) for counting mouse-up and mouse-down events.
--
-- Said another way, using the terminology of functional reactive programming, the 'MouseSignal'
-- data type in "Happlets.Control.Mouse" is a "signal" whereas the 'Mouse2D' data type is an actual
-- "event".
data Mouse2D n
  = Mouse2D
    { theMouse2DPosition :: !(Point2D n)
    , theMouse2DModifiers :: !ModifierBits
    }
  deriving (Eq, Functor)

-- | Events received directly from the operating system specify the event coordinate in
-- pixels. Events of this type can be transformed to other coordinate systems using the 'fmap'
-- function.
type PixelMouse = Mouse2D SampCoord

-- | This data type is used when installing event handlers to specify which mouse button to respond
-- to when an event occurs. You can install both left and right button event handlers
-- simultaneously, all event handlers will be triggered as events occur. The left and right mouse
-- button each have their own individual FSM state information so left and right event handlers may
-- be triggered simultaneously.
data MouseButton = RightMouseButton | LeftMouseButton
  deriving (Eq, Ord, Show, Enum)

instance Has2DOrigin Mouse2D where { origin2D = mouse2DPosition; }

roleMouseEvents :: RoleMouseEvents model
roleMouseEvents = RoleMouseEvents
  { theActionMouseDown = Nothing
  , theActionMouseClick = Nothing
  , theActionMouseDouble = Nothing
  , theActionMouseDrag = Nothing
  }

roleMouseEventsNull :: RoleMouseEvents model -> Bool
roleMouseEventsNull = \ case
  RoleMouseEvents
   { theActionMouseDown = Nothing
   , theActionMouseClick = Nothing
   , theActionMouseDouble = Nothing
   , theActionMouseDrag = Nothing
   } -> True
  _  -> False

roleMouseEventsMaybe :: RoleMouseEvents model -> Maybe (RoleMouseEvents model)
roleMouseEventsMaybe rme = guard (not $ roleMouseEventsNull rme) >> pure rme

-- | A lens into a 'Role', either 'rightMouseButtonActions' or 'leftMouseButtonActions', that is
-- constructed from a 'MouseButton' value
actionMouseButton :: MouseButton -> Lens' (Role model) (RoleMouseEvents model)
actionMouseButton = \ case
  RightMouseButton -> rightMouseButtonActions
  LeftMouseButton  -> leftMouseButtonActions

-- | This lens is used to instantiate the 'origin2D' instance for the 'MouseEvent' data type.
mouse2DPosition :: Lens' (Mouse2D n) (Point2D n)
mouse2DPosition = lens theMouse2DPosition $ \ a b -> a{ theMouse2DPosition = b }

-- | Keyboard modifiers received from the system-level 'Mouse' event data structure.
mouse2DModifiers :: Lens' (Mouse2D n) ModifierBits
mouse2DModifiers = lens theMouse2DModifiers $ \ a b -> a{ theMouse2DModifiers = b }

-- | Return the 'ActorEventHandlerStats' for the @'TypedActor' model@ of type that is currently
-- acting out this 'Script'.
getEventHandlerStats :: Script model ActorEventHandlerStats
getEventHandlerStats = scriptGetsScene $ view sceneStats

diffActorEventHandlerStats
  :: ActorEventHandlerStats
  -> ActorEventHandlerStats
  -> ActorEventHandlerStats
diffActorEventHandlerStats a b =
  let diff f = f a - f b in
  ActorEventHandlerStats
  { countActors            = diff countActors
  , countActionDraw        = diff countActionDraw
  , countActionRedraw      = diff countActionRedraw
  , countActionSelect      = diff countActionSelect
  , countActionKeyboard    = diff countActionKeyboard
  , countActionMouseOver   = diff countActionMouseOver
  , countActionMouseRight  =
      diffButtonEventHandlerStats (countActionMouseLeft a) (countActionMouseLeft b)
  , countActionMouseLeft   =
      diffButtonEventHandlerStats (countActionMouseRight a) (countActionMouseRight b)
  , countActionAnimation   = diff countActionAnimation
  }

diffButtonEventHandlerStats
  :: Maybe MouseEventHandlerStats
  -> Maybe MouseEventHandlerStats
  -> Maybe MouseEventHandlerStats
diffButtonEventHandlerStats a b = case (a, b) of
  (Nothing, Nothing) -> Nothing
  (Just  a, Nothing) -> Just a
  (Nothing, Just  b) -> Just b
  (Just  a, Just  b) -> 
    let diff f = f a - f b in Just $
    MouseEventHandlerStats
    { countActionMouseDown   = diff countActionMouseDown
    , countActionMouseClick  = diff countActionMouseClick
    , countActionMouseDouble = diff countActionMouseDouble
    , countActionMouseDrag   = diff countActionMouseDrag
    }

roleEventStats :: forall any . Role any -> ActorEventHandlerStats
roleEventStats r = ActorEventHandlerStats
  { countActors            = 1
  , countActionDraw        = if drawingIsNull (theActionDraw r) then 0 else 1
  , countActionRedraw      = inc theActionRedraw
  , countActionSelect      = inc theActionSelect
  , countActionKeyboard    = inc theActionKeyboard
  , countActionMouseOver   = inc theActionMouseOver
  , countActionMouseRight  = mouseEventStats $ theActionRightMouse r
  , countActionMouseLeft   = mouseEventStats $ theActionLeftMouse r
  , countActionAnimation   = inc theActionAnimation
  } where
    inc :: (Role any -> Maybe void) -> Int
    inc fromRole = maybe 0 (const 1) (fromRole r)

mouseEventStats :: forall any . Maybe (RoleMouseEvents any) -> Maybe MouseEventHandlerStats
mouseEventStats = maybe Nothing $ \ r -> if roleMouseEventsNull r then Nothing else Just $
  MouseEventHandlerStats
  { countActionMouseDown = inc r theActionMouseDown
  , countActionMouseClick = inc r theActionMouseClick
  , countActionMouseDouble = inc r theActionMouseDouble
  , countActionMouseDrag = inc r theActionMouseDrag
  }
  where
    inc :: RoleMouseEvents any -> (RoleMouseEvents any -> Maybe void) -> Int
    inc r fromRole = maybe 0 (const 1) (fromRole r)

roleMouseEventStatsFor :: MouseButton -> (ActorEventHandlerStats -> Maybe MouseEventHandlerStats)
roleMouseEventStatsFor = \ case
  RightMouseButton -> countActionMouseRight
  LeftMouseButton  -> countActionMouseLeft

-- | not for export
--
-- A function you can use to define a widget using do-notation and lens 'State' operators like '.=',
-- '%=', and 'use'
role :: model -> Role model
role model = Role
  { theRoleModel         = model
  , theRoleLabel         = ""
  , theActionDraw        = mempty
  , theActionRedraw      = Nothing
  , theActionSelect      = Nothing
  , theActionKeyboard    = Nothing
  , theActionMouseOver   = Nothing
  , theActionLeftMouse   = Nothing
  , theActionRightMouse  = Nothing
  , theActionAnimation   = Nothing
  }

-- | A lens to inspect and update the model inside of the 'Role'.
roleModel :: Lens' (Role model) model
roleModel = lens theRoleModel $ \ a b -> a{ theRoleModel = b }

-- | An arbitrary string label you can use to query 'Roles' in a set. Labels do not need to be
-- unique.
roleLabel :: Lens' (Role model) Strict.Text
roleLabel = lens theRoleLabel $ \ a b -> a{ theRoleLabel = b }

actionDraw :: Lens' (Role model) (Drawing SampCoord)
actionDraw = lens theActionDraw $ \ a b -> a{ theActionDraw = b }

actionRedraw :: Lens' (Role model) (Maybe (Drawing SampCoord))
actionRedraw = lens theActionRedraw $ \ a b -> a{ theActionRedraw = b }

actionSelect :: Lens' (Role model) (Maybe (EventAction SampCoord model))
actionSelect = lens theActionSelect $ \ a b -> a{ theActionSelect = b }

actionKeyboard :: Lens' (Role model) (Maybe (EventAction Keyboard model))
actionKeyboard = lens theActionKeyboard $ \ a b -> a{ theActionKeyboard = b }

-- | Set the action to perform when an animation step occurs.
actionAnimation :: Lens' (Role model) (Maybe (EventAction UTCTime model))
actionAnimation = lens theActionAnimation $ \ a b -> a{ theActionAnimation = b }

actionMouseOver :: Lens' (Role model) (Maybe (EventAction PixelMouse model))
actionMouseOver = lens theActionMouseOver $ \ a b -> a{ theActionMouseOver = b }

rightMouseButtonActions :: Lens' (Role model) (RoleMouseEvents model)
rightMouseButtonActions = lens
  (maybe roleMouseEvents id . theActionRightMouse)
  (\ a b -> a{ theActionRightMouse = roleMouseEventsMaybe b })

leftMouseButtonActions :: Lens' (Role model) (RoleMouseEvents model)
leftMouseButtonActions = lens
  (maybe roleMouseEvents id . theActionLeftMouse)
  (\ a b -> a{ theActionLeftMouse = roleMouseEventsMaybe b })

mouseButtonDown :: Lens' (RoleMouseEvents model) (Maybe (EventAction PixelMouse model))
mouseButtonDown = lens theActionMouseDown $ \ a b -> a{ theActionMouseDown = b }

mouseButtonClick :: Lens' (RoleMouseEvents model) (Maybe (EventAction PixelMouse model))
mouseButtonClick = lens theActionMouseClick $ \ a b -> a{ theActionMouseClick = b }

mouseButtonDouble :: Lens' (RoleMouseEvents model) (Maybe (EventAction PixelMouse model))
mouseButtonDouble = lens theActionMouseDouble $ \ a b -> a{ theActionMouseDouble = b }

mouseButtonDrag :: Lens' (RoleMouseEvents model) (Maybe (EventAction (Maybe PixelMouse) model))
mouseButtonDrag = lens theActionMouseDrag $ \ a b -> a{ theActionMouseDrag = b }

actionMouseDown :: MouseButton -> Lens' (Role model) (Maybe (EventAction PixelMouse model))
actionMouseDown b = cloneLens (actionMouseButton b) . mouseButtonDown

actionMouseClick :: MouseButton -> Lens' (Role model) (Maybe (EventAction PixelMouse model))
actionMouseClick b = cloneLens (actionMouseButton b) . mouseButtonClick

actionMouseDouble :: MouseButton -> Lens' (Role model) (Maybe (EventAction PixelMouse model))
actionMouseDouble b = cloneLens (actionMouseButton b) . mouseButtonDouble

actionMouseDrag :: MouseButton -> Lens' (Role model) (Maybe (EventAction (Maybe PixelMouse) model))
actionMouseDrag b = cloneLens (actionMouseButton b) . mouseButtonDrag

----------------------------------------------------------------------------------------------------

data EventAction event model
  = EventAction
    { theActionText :: !Strict.Text
      -- ^ The source code that defined this action, if any.
    , theAction :: !(event -> Script model ())
    }

-- | Create a closure for a 'Script' function that updates a value of type @private@ in reaction to
-- some @event@. This function implements the actual logic for how a closure updates it's private
-- data of type @private@ using the public data of type @public@. Except for 'encloseDrawAction',
-- all other "staging" functions call into this function. Although 'encloseDrawAction' has nearly
-- identical logic to 'encloseEventScript' it is a reader monad rather than a state monad, so must
-- be treated slightly differently.
--
-- Note that this function calls 'runScript' which may in turn call 'encloseRole', and 'encloseRole'
-- will in turn call 'ancloseEventAction', and 'encloseEventAction' calls this function
-- again. However, there is no infinite loop, because the 'encloseEventAction' function only returns
-- a thunk containing a call to this 'encloseEventScript' function, so it does not immediately
-- evaluate 'encloseEventScript' in an infinite loop.
encloseEventScript
  :: TypedActor model
  -> (event -> Script model a)
  -> (event -> Script Actor a)
encloseEventScript ref act event =
  Script $ ConsequenceT $ StateT $ \ st0 -> do
    (result, st) <- runScript (act event) (theScriptScene st0) ref
    let actor@(Actor actorRef) = theUntypedActor (theScriptActor st0)
    role <- readIORef actorRef
    return
      ( result
      , ScriptState
        { theScriptRole  = role
        , theScriptActor = TypedActor
          { theTypedActorRole = actorRef
          , theUntypedActor = actor
          }
        , theScriptScene = theScriptScene st
        , theScriptRoleUpdated = theScriptRoleUpdated st
        }
      )

-- | Evaluates an 'EventAction' function.
runEventAction :: EventAction event model -> event -> Script model ()
runEventAction (EventAction{theAction=act}) = act

-- | Create a closure around an 'EventAction' function, hiding the data of type @private@. This
-- function calls 'encloseEventScript' to create the closure.
encloseEventAction
  :: TypedActor model
  -> EventAction event model
  -> EventAction event Actor
encloseEventAction ref (EventAction{theActionText=txt,theAction=act}) = EventAction
  { theActionText = txt
  , theAction     = encloseEventScript ref act
  }

----------------------------------------------------------------------------------------------------

-- | An 'Actor' is anything that can be made visible and interactive on a Happlets 'Scene'
-- canvas. An 'Actor' is essentially an untyped "object" (or in functional programming terms, a
-- "closure") which contains some arbitrary @model@ data that is private or hidden, but behaves
-- according to this @model@. Every 'Actor' is constructed from a 'TypedActor' for which the @model@
-- data type is known to the type system and can be manipulated directly.
--
-- The benefit of using an 'Actor', as opposed to a 'TypedActor' is that an 'Actor' is a simple
-- concrete type (it has no type variable indicating it's internal state), so you can store 'Actor's
-- that contain many different 'TypedActors' of many different @model@ types in a single
-- 'Data.Traversable.Traversable' data structure like a list or vector, as though that data
-- structure contained heterogeneous data. The disadvantage of using an 'Actor' is that there no way
-- to directly manipulate the @model@ private data.
newtype Actor = Actor (IORef (Role Actor))

-- | This is a typed variant of the 'Actor' data type in which the @model@ data type is attached,
-- allowing you to define 'Script's that manipulate the @model@ directly. In object-oriented
-- programming temrs, the @model@ is the "private data" for the 'Actor' object.
--
-- The 'TypedActor' contains a reference to the untyped 'Actor' which you can retrieve using
-- 'theUntypedActor'. Any changes made to the 'TypedActor' are immediately reflected on the untyped
-- 'Actor'. Any code that maintains a reference to the 'TypedActor' can make updates to the 'Actor's
-- hidden private data @model@ for long as that reference is in scope.
--
-- To create a 'TypedActor' and place it on the Happlets canvas, use the 'actor' function.
data TypedActor model
  = TypedActor
    { theTypedActorRole :: !(IORef (Role model))
    , theUntypedActor   :: !Actor
    }

actorTypedActor :: Actor -> TypedActor Actor
actorTypedActor self@(Actor ref) = TypedActor
  { theTypedActorRole = ref
  , theUntypedActor = self
  }

-- | Delegate or send a new 'Keyboard' event to the current 'TypedActor' of the 'Script' function
-- context.
actorKeyboard :: Keyboard -> Script model ()
actorKeyboard key =
  scriptGetsRole theActionKeyboard >>= maybe (pure ()) (flip runEventAction key)

-- | Delegate or send a new 'PixelMouse' mouse-over event to the current 'TypedActor' of the
-- 'Script' function context.
actorMouseOver :: PixelMouse -> Script model ()
actorMouseOver mouse =
  scriptGetsRole theActionMouseOver >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new mouse down event to the current 'TypedActor' of the 'Script' function
-- context.
actorDown :: MouseButton -> PixelMouse -> Script model ()
actorDown button mouse =
  scriptGetsRole (view $ actionMouseDown button) >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new mouse click event to the current 'TypedActor' of the 'Script' function
-- context.
actorClick :: MouseButton -> PixelMouse -> Script model ()
actorClick button mouse =
  scriptGetsRole (view $ actionMouseClick button) >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'MouseSignal' double click event to the current 'TypedActor' of the
-- 'Script' function context.
actorDoubleClick :: MouseButton -> PixelMouse -> Script model ()
actorDoubleClick button mouse =
  scriptGetsRole (view $ actionMouseDouble button) >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new 'Mouse' double click event to the current 'TypedActor' of the 'Script'
-- function context.
actorDrag :: MouseButton -> Maybe PixelMouse -> Script model ()
actorDrag button mouse =
  scriptGetsRole (view $ actionMouseDrag button) >>= maybe (pure ()) (flip runEventAction mouse)

-- | Delegate or send a new animation event to the current 'TypedActor' of the 'Script' function
-- context.
actorAnimate :: UTCTime -> Script model ()
actorAnimate t =
  scriptGetsRole theActionAnimation >>= maybe (pure ()) (flip runEventAction t)

-- | Calls all relevant "enclose" functions to create a closure around an entire 'Role' by creating
-- a closure around an every 'EventAction' or 'DrawAction' function stored within the 'Role'.
encloseRole
  :: TypedActor model
  -- ^ the reference that will store the private data of the closure.
  -> Role model
  -- ^ the functions that operate on the private data of the closure.
  -> Role Actor
encloseRole ref pack = Role
  { theRoleModel         = theUntypedActor ref
  , theRoleLabel         = theRoleLabel pack
  , theActionDraw        = theActionDraw pack
  , theActionRedraw      = theActionRedraw pack
  , theActionSelect      = encloseEventAction ref <$> theActionSelect    pack
  , theActionKeyboard    = encloseEventAction ref <$> theActionKeyboard  pack
  , theActionMouseOver   = encloseEventAction ref <$> theActionMouseOver pack
  , theActionRightMouse  = encloseMouseEvents ref $ theActionRightMouse  pack
  , theActionLeftMouse   = encloseMouseEvents ref $ theActionLeftMouse   pack
  , theActionAnimation   = encloseEventAction ref <$> theActionAnimation pack
  }

-- | Calls all relevant "enclose" functions to create a closure around an entire 'RoleMouseEvents'
-- data structure, just like 'encloseRole' but for 'RoleMouseEvents'.
encloseMouseEvents
  :: TypedActor model
  -> Maybe (RoleMouseEvents model)
  -> Maybe (RoleMouseEvents Actor)
encloseMouseEvents ref = maybe Nothing $ \ pack -> Just $
  RoleMouseEvents
  { theActionMouseDown   = encloseEventAction ref <$> theActionMouseDown pack
  , theActionMouseClick  = encloseEventAction ref <$> theActionMouseClick pack
  , theActionMouseDouble = encloseEventAction ref <$> theActionMouseDouble pack
  , theActionMouseDrag   = encloseEventAction ref <$> theActionMouseDrag pack
  }

-- | not for export
--
-- This function creates a 'TypedActor' without registering it with a 'Registry' in a 'Scene'.
makeActorIO :: Role model -> IO (TypedActor model)
makeActorIO role = do
  roleref <- newIORef role
  actref  <- newIORef $ error "'newActor' failed to initialize reference"
  let actor = Actor actref
  let typed = TypedActor
        { theTypedActorRole = roleref
        , theUntypedActor   = actor
        }
  writeIORef actref $ encloseRole typed role
  return typed

-- | not for export
--
-- Creates a new 'TypedActor' and initializes it, but does not stage the constructed actor into any
-- 'Scene'.
makeActor :: Script model a -> model -> Script any (a, TypedActor model)
makeActor init model =
  Script $ ConsequenceT $ StateT $ \ st0 -> do
    typed <- makeActorIO $ role model
    (result, st) <- runScript init (theScriptScene st0) typed
    return
      ( (\ a -> (a, typed)) <$> result
      , st0
        { theScriptScene = theScriptScene st
        , theScriptRoleUpdated = theScriptRoleUpdated st
        }
      )

-- | Create a new 'TypedActor' and stages it in the current 'Scene' so that it can start responding
-- to events.
actor :: Script model () -> model -> Script any (TypedActor model)
actor init model = snd <$> makeActor init model

-- | Same as the 'actor' function, but for 'actress' the @model@ is constrained to instantiate the
-- 'Monoid' typeclass. So 'actress' does not take an initial @model@ value as the 'TypedActor' will
-- be initialized with the default 'mempty' value.
--
-- The word 'actress' is used here only because it is a shorter name than @monoidActor@, and apart
-- from the 'Monoid' type constraint, there is otherwise no difference between an 'actor' and
-- 'actress'.
actress :: Monoid model => Script model () -> Script any (TypedActor model)
actress = flip actor mempty

----------------------------------------------------------------------------------------------------

-- | A 'Scene' is a model of a 2D canvas containing many 'Actor' objects, within which all can
-- update the canvas and can respond to canvas events. When an 'Act' is first constructed by
-- 'newActHapplet' it already has a new 'Scene' ready to be populated with 'Actor's, so it is not
-- necessary to create a new 'Scene', but keeping 'Actor's organized into 'Scene's and changing
-- between 'Scene's is a good way to keep a user interface less cluttered.
--
-- A 'Scene' itself can be used as the @model@ of a 'TypedActor', so you can use the 'Scene' as an
-- 'Actor' in another scene, and events can be delegated to the 'Scene' through the 'TypedActor'
-- event handler APIs. When you create a 'Scene' using 'newScene', a 'TypedActor' containing the
-- 'Scene' is returned.
data Scene
  = Scene
    { theSceneRegistry   :: !(Registry (Role Actor))
      -- ^ The objects in this scene
    , theSceneFocus      :: !(Maybe Actor)
      -- ^ A reference to the object in 'theSceneRegistry' that currently responds to keyboard
      -- events or double-click events. Also, an object that is being dragged necessarily has focus.
    , theSceneStats      :: !ActorEventHandlerStats
      -- ^ Statistics about the number of event handlers installed across all 'Actor's within the
      -- 'Scene', this helps to determine if the 'Scene' should install it's own event handler to
      -- delegate events to any of it's 'Actor's.
    , theSceneGlobalBounds :: !(Rect2D SampCoord)
      -- ^ The 'Rect2D', in global coordinates of this 'Scene's viewable window, in the 'GUI'
      -- monad's coordinate system.
    , sceneWriteErrorLog :: !(LogReporter IO)
    }

instance CanWriteReports (Script any) where
  report lvl msg =
    scriptGetsScene sceneWriteErrorLog >>= \ log -> scriptIO $ log lvl msg

-- | not for export
--
-- The Registry for the 'Scene' contains a reference to all 'Actors'.
sceneRegistry :: Lens' Scene (Registry (Role Actor))
sceneRegistry = lens theSceneRegistry $ \ a b -> a{ theSceneRegistry = b }

-- | The 'Actor' that currently has focus.
sceneFocus :: Lens' Scene (Maybe Actor)
sceneFocus = lens theSceneFocus $ \ a b -> a{ theSceneFocus = b }

-- | The 'Rect2D', in global coordinates of this 'Scene's viewable window, in the 'GUI' monad's
-- coordinate system.
sceneGlobalBounds :: Lens' Scene (Rect2D SampCoord)
sceneGlobalBounds = lens theSceneGlobalBounds $ \ a b -> a{ theSceneGlobalBounds = b }

-- | not for export
--
-- Tracks statistics on how many elements in a 'Scene' respond to particular events. It is
-- determined by an aggregate computation over all @('Role' 'Actor')@ items in a 'Scene's
-- 'Registry'.
sceneStats :: Lens' Scene ActorEventHandlerStats
sceneStats = lens theSceneStats $ \ a b -> a{ theSceneStats = b }

-- | not for export
--
-- Place an 'Actor' on stage, making it visible and able to respond to events.
stageActor :: Actor -> Script any ()
stageActor (Actor actorRef) =
  scriptGets (view $ scriptScene . sceneRegistry) >>=
  scriptIO . registryEnqueue actorRef >>
  scriptIO (roleEventStats <$> readIORef actorRef) >>= \ stats ->
  report DEBUG (Strict.pack $ "Staging actor, stats:\n" <> show stats) >>
  (scriptModify . ((scriptScene . sceneStats) <>~) $ stats)

-- | Place a 'TypedActor' on stage, making it visible and able to respond to events. After defining
-- a 'TypedActor' using 'actor' or 'actress', it is necessary to call this 'onStage' function in
-- order for the 'TypedActor' begin acting on stage and responding to events and cues.
onStage :: TypedActor model -> Script any ()
onStage = stageActor . theUntypedActor

-- | Function used internally by 'newActHapplet' to create a new scene. Scenes that can be
-- manipulated by end users of this API are always wrapped in a 'TypedActor'.
makeEmptyScene :: LogReporter IO -> Int -> IO Scene
makeEmptyScene logReporter size = do
  registry <- newRegistry size
  return Scene
    { theSceneRegistry     = registry
    , theSceneFocus        = Nothing
    , theSceneStats        = mempty
    , theSceneGlobalBounds = rect2D
    , sceneWriteErrorLog   = logReporter
    }

-- | Like the 'Control.Exception.bracket' function, evaluates a 'Script' function, but ensures a
-- resource is released if the 'Script' function fails. If the resource releasing function also
-- fails, it's failure is ignored. This does not catch exceptions thrown by
-- 'Control.Exception.throw' or 'error'.
sceneBracket
  :: Script any resource
  -> (resource -> Script any ())
  -> (resource -> Script any a)
  -> Script any a
sceneBracket acquire release f0 =
  acquire >>= \ resource ->
  let (Script (ConsequenceT releaseResource)) = release resource in
  let (Script (ConsequenceT f)) = f0 resource in
  Script $ ConsequenceT $ f <* releaseResource

-- | not for export
--
-- Calls 'actor'' to initialize a new 'TypedActor' without staging the constructed actor.
sceneToTypedActor :: Script Scene a -> Scene -> Script any (a, TypedActor Scene)
sceneToTypedActor init =
  makeActor $
  init <*
  ( use sceneRegistry >>=
    scriptIO . sceneRecountActionStats >>=
    assign sceneStats
  )

-- | A 'Scene' is a sub-group of 'Actors' that can be created within the current top-level
-- 'Scene'. This function creates an empty 'Scene' with space pre-allocated for an integer number of
-- 'Actor's to be stored, although 16 is the minimum pre-allocation size. It then evaluates an
-- initializer function that should fill the 'Scene' with 'Actor's.
--
-- The state value of the 'Script' continuation will be a value of the 'Scene' data type, but there
-- will not be much you can do to manipulate it directly. The 'Script' continuation given here for
-- the most part will simply call 'actor' or 'actress' to place actors into the scene.
--
-- __NOTE:__ that the @'Script' 'Scene' ()@ function is really only to allow you to install 'Actor's
-- into the 'Scene' using the 'actor' or 'actress' functions. You may install event handlers into
-- the 'Scene' using functions like 'onKeyboard', but these event handlers will not be used in a
-- situation where all other actors in the scene have not already captured and dispatched the events
-- received. So any event handlers you install during the initialize 'Script' evaluation should only
-- be the "last resort" event handlers that are only triggered when no other 'Actor's have responded
-- to the event.
--
-- See also: newActHapplet
newScene :: Int -> Script Scene () -> Script any (TypedActor Scene)
newScene size init =
  scriptGetsScene sceneWriteErrorLog >>= \ logReporter ->
  scriptIO (makeEmptyScene logReporter size) >>=
  sceneToTypedActor init >>= \ ((), actor) ->
  onStage actor >>
  return actor

sceneRecountActionStats :: Registry (Role Actor) -> IO ActorEventHandlerStats
sceneRecountActionStats registry =
  reactEventRegistryIO True
  (\ _halt roleRef ->
     liftIO (readIORef roleRef) >>=
     modify . mappend . roleEventStats >>
     pure empty
  )
  registry
  mempty

-- | This function creates an 'EventAction' that evaluates 'triggerEventHandlers' on all elements in
-- a 'Scene'.
reactScene
  :: (forall model . Lens' (Role model) (Maybe (EventAction event model)))
  -> EventAction event Scene
reactScene handler =
  EventAction
  { theActionText = ""
  , theAction = triggerEventHandlers scriptIO ((.) catchConsequence . scriptWithActor) handler
  }

-- | Check current statistics on the current 'Scene' and update delegate event handlers.
delegateEvents
  :: (ActorEventHandlerStats -> Int)
  -> (forall model . Lens' (Role model) (Maybe (EventAction event model)))
  -> Script Scene ()
delegateEvents checkStats handle = do
  s <- use sceneStats
  scriptModify $
    scriptRole . cloneLens handle .~
    if checkStats s > 0 then Just (reactScene handle) else Nothing

-- | Call 'delegateEvents' on a 'RoleMouseEvents' handler.
delegateButtonEvents
  :: (MouseEventHandlerStats -> Int)
  -> (forall model . Lens' (RoleMouseEvents model) (Maybe (EventAction event model)))
  -> MouseButton
  -> Script Scene ()
delegateButtonEvents checkStats handle button =
  delegateEvents
  (maybe 0 checkStats . roleMouseEventStatsFor button)
  (actionMouseButton button . handle)

delegateSelectEvents :: Script Scene ()
delegateSelectEvents = delegateEvents countActionSelect actionSelect

delegateKeyboardEvents :: Script Scene ()
delegateKeyboardEvents = delegateEvents countActionKeyboard actionKeyboard

delegateMouseOverEvents :: Script Scene ()
delegateMouseOverEvents = delegateEvents countActionMouseOver actionMouseOver

delegateMouseDownEvents :: MouseButton -> Script Scene ()
delegateMouseDownEvents = delegateButtonEvents countActionMouseDown mouseButtonDown

delegateMouseClickEvents :: MouseButton -> Script Scene ()
delegateMouseClickEvents = delegateButtonEvents countActionMouseClick mouseButtonClick

delegateMouseDoubleClickEvents :: MouseButton -> Script Scene ()
delegateMouseDoubleClickEvents = delegateButtonEvents countActionMouseDouble mouseButtonDouble

delegateMouseDragEvents :: MouseButton -> Script Scene ()
delegateMouseDragEvents = delegateButtonEvents countActionMouseDrag mouseButtonDrag

-- | Delegate all mouse button event handlers for a particular 'MouseButton'.
delegateMouseButtonEvents :: MouseButton -> Script Scene ()
delegateMouseButtonEvents a = do
  delegateMouseDownEvents a
  delegateMouseClickEvents a
  delegateMouseDoubleClickEvents a
  delegateMouseDragEvents a

delegateAnimationEvents :: Script Scene ()
delegateAnimationEvents = delegateEvents countActionAnimation actionAnimation

-- | This function may be used to update the event hanlders on a @'TypedActor' 'Scene'@ whenever the
-- contents of the 'Scene' changes.
--
-- What this function actually does is check 'theSceneStats' and installs the correct event handlers
-- into the 'Scene's top-level event handler to automatically delegate events to the 'Actor's that
-- have been staged into the 'Scene'. If the scene has no staged 'Actor's which respond to a
-- particular event, the event handler for that particular event is set to 'Nothing'.
--
-- Note that event delegation can only be performed by 'Scene' values, as these are the only values
-- that can contain other 'Actor's.
--
-- This function calls all of 'delegateSelectEvents', 'delegateKeyboardEvents',
-- 'delegateMosueOverEvents', 'delegateMouseButtonEvents' (for both 'RightMouseButton' and
-- 'LeftMouseButton), and 'delegateAnimationEvents'.
delegateSceneEvents :: Script Scene ()
delegateSceneEvents = do
  delegateSelectEvents
  delegateKeyboardEvents
  delegateMouseOverEvents
  delegateMouseButtonEvents RightMouseButton
  delegateMouseButtonEvents LeftMouseButton
  delegateAnimationEvents

----------------------------------------------------------------------------------------------------

-- | This is the Reader environment that can be inspected within an 'ActorSelect' function using the
-- 'ask' or 'asks' function.
data ActorInfo
  = ActorInfo
    { actorEvents :: ActorEventHandlerStats
    , actorLabel :: !Strict.Text
    }

-- | This function type is used by the 'selectInScene' function. This function should inspect the
-- 'ActorInfo' value provided by way of the 'ask' or 'asks' function. Return a value of type @fold@
-- to select the 'Actor', all returned values are combined using 'mappend', and the inspected
-- 'Actor' is stored in the new 'Scene' as a side effect. Evaluate to 'empty' to ignore the 'Actor'
-- (it will not be stored in the new 'Scene'). Evaluate to 'cancel' to halt the loop.
newtype ActorSelect a = ActorSelect (ReaderT ActorInfo (ConsequenceT IO) a)
  deriving (Functor, Applicative, Monad, MonadReader ActorInfo, MonadFail)

instance Consequential ActorSelect where { cancel = ActorSelect $ lift cancel; }

-- | This function constructs a new 'Scene' by scanning through the current 'Scene' in the 'Script'
-- context and picking out all 'Actor's that satisfy an 'ActorSelect' function.
--
-- The new 'Scene' is not staged or made visible, call 'onStage' on the result of this function if
-- you want it to be satged.
selectInScene
  :: Monoid fold
  => ActorSelect fold
  -> fold
  -> Script any (TypedActor Scene, fold)
selectInScene (ActorSelect select) fold = do
  logReporter <- scriptGetsScene sceneWriteErrorLog
  scene <- scriptIO $ makeEmptyScene logReporter 16
  fold  <- reactEventRegistry True
    scriptIO
    (\ halt roleRef ->
       lift (scriptIO $ readIORef roleRef) >>= \ role ->
       lift
       ( scriptIO $
         runConsequenceT $
         runReaderT select ActorInfo
         { actorEvents = roleEventStats role
         , actorLabel  = theRoleLabel   role
         }
       ) >>= \ case
        ActionOK  fold -> do
          modify (<> fold)
          lift $ stageActor $ theRoleModel role
          halt $ ActionOK ()
        ActionHalt     -> pure ActionHalt
        ActionCancel   -> pure ActionCancel
        ActionFail msg -> pure (ActionFail msg)
    )
    (theSceneRegistry scene)
    fold
  -- Construct a new 'TypedActor' for the newly created 'Scene'.
  (fold, actor) <- sceneToTypedActor (return fold) scene
  return (actor, fold)

----------------------------------------------------------------------------------------------------

-- | An 'Act' (noun) is a container with 1 or more 'Scene's. This is the root object of the
-- 'Happlet'.
data Act
  = Act
    { theActCurrentScene :: !(Role Scene)
      -- ^ The 'Role' here is initialized by 'newActHapplet'. Any event handlers that are installed
      -- on the 'Scene' itself are triggered as a last resort, only if none of the other
      -- 'TypedActor's installed into the 'Scene' capture and dispatch the event for themselves.
    , theLeftMouseState  :: !MouseState
    , theRightMouseState :: !MouseState
    , theCurrentDragItem :: !(Maybe (Role Actor))
    }

actMouseButtonLens :: MouseButton -> Lens' Act MouseState
actMouseButtonLens = \ case
  RightMouseButton -> actRightMouseState
  LeftMouseButton  -> actLeftMouseState

actLeftMouseState :: Lens' Act MouseState
actLeftMouseState = lens theLeftMouseState $ \ a b -> a{ theLeftMouseState = b }

actRightMouseState :: Lens' Act MouseState
actRightMouseState = lens theRightMouseState $ \ a b -> a{ theRightMouseState = b }

--actCurrentDragItem :: Lens' Act (Maybe (Role Actor))
--actCurrentDragItem = lens theCurrentDragItem $ \ a b -> a{ theCurrentDragItem = b }

actCurrentScene :: Lens' Act (Role Scene)
actCurrentScene = lens theActCurrentScene $ \ a b -> a{ theActCurrentScene = b }

onScene :: GUI provider Scene a -> GUI provider Act a
onScene = onSubModel (actCurrentScene . roleModel)

-- | Execute a 'Script' within the context of the current @'GUI' provider 'Scene'@ context, directly
-- specifying a 'TypedActor' to perform the script. You can evaluate this function in 'onScene' to
-- evaluate within a @'GUI' provider 'Act'@ context.
--
-- See also: 'scriptWithActor', 'scriptWithTypedActor', 'guiRunScriptActor'
guiRunScriptTypedActor
  :: ProvidesLogReporter provider
  => Script model a
  -> TypedActor model
  -> GUI provider Scene (Consequence a)
guiRunScriptTypedActor f typed = do
  (result, scene) <- get >>= liftIO . flip (runScript f) typed
  state $ const (result, theScriptScene scene)

-- | Like 'guiRunScriptTypedActor', but performs the 'Script' with an untyped 'Actor'.
--
-- See also: 'scriptWithTypedActor', 'scriptWithActor'.
guiRunScriptActor
  :: ProvidesLogReporter provider
  => Script Actor a
  -> Actor
  -> GUI provider Scene (Consequence a)
guiRunScriptActor f untyped = do
  (result, scene) <- get >>=
    liftIO .
    flip (runScript (f <* scriptModify (scriptRoleUpdated .~ False)))
    (actorTypedActor untyped)
  state $ const (result, theScriptScene scene)
  
-- | This function uses 'reactEventRegistry' to step through the event 'Registry' of a 'Scene', uses
-- a lens to select a @thing@ from each 'Role' of each 'Actor' in the 'Registry', and executes a
-- continuation function that 'Role' and that @thing@ for all 'Role's for which the @thing@ is not
-- 'Nothing'. Importantly, this function also udpates the 'ActorEventHandlerStats' for the 'Scene'
-- using the 'diffActorEventHandlerStats' function, which also tracks which 'Actor's need to be
-- redrawn, and thus which regions need to be deleted.
forActorsInRegistry
  :: (Monad m, MonadState Scene m, CanWriteReports m)
  => Bool -- ^ Scan upwards? (Fiven as first argument to 'reactEventRegistry'.)
  -> Bool -- ^ Should halt on first Role to evaluate to a successful 'ActionOK' result.
  -> (forall a . IO a -> m a)
  -> Lens' (Role Actor) (Maybe thing)
  -> (thing -> Actor -> m (Consequence ()))
  -> m ()
forActorsInRegistry upward haltWhenOK liftIO thingLens runUpdate =
  use sceneRegistry >>= \ registry ->
  ( reactEventRegistry upward liftIO
    (\ halt roleRef ->
      lift (liftIO $ readIORef roleRef) >>= \ role0 ->
      case role0 ^. thingLens of
        Nothing    -> pure empty
        Just thing -> do
          consequence <- lift (runUpdate thing $ Actor roleRef)
          role <- lift (liftIO $ readIORef roleRef)
          let stats = roleEventStats role
          let update stats =
                modify $ mappend $!
                diffActorEventHandlerStats stats (roleEventStats role0)
          case consequence of
            ActionOK   ()  -> update stats >> (if haltWhenOK then halt else pure) consequence
            ActionHalt     -> update stats >> pure consequence
            ActionCancel   -> update mempty >> pure consequence
            ActionFail msg -> lift (report ERROR msg) >> update mempty >> pure consequence
    )
    registry
    mempty
  ) >>=
  modifying sceneStats . (<>)

-- | Not for export
--
-- With the given @event@, call the 'EventAction' taken by the given 'Lens', in order of most
-- recently added to least recently added, for each 'Actor's in the current 'Act'. Stop calling
-- 'EventActions' after the first 'EventAction' to return a 'pure' or 'empty' consequence.
triggerEventHandlers
  :: (Monad m, MonadState Scene m, CanWriteReports m)
  => (forall a . IO a -> m a)
  -> (Script Actor () -> Actor -> m (Consequence ()))
  -> Lens' (Role Actor) (Maybe (EventAction event Actor))
  -> event
  -> m ()
triggerEventHandlers liftIO liftScript handler event = do
  report DEBUG ("triggerEventHandlers -> forActorsInRegistry")
  forActorsInRegistry False True liftIO handler $ \ action actor ->
    liftScript (runEventAction action event) actor

guiTriggerEventHandlers
  :: (HappletWindow provider render, Happlet2DGraphics render, ProvidesLogReporter provider)
  => Lens' (Role Actor) (Maybe (EventAction event Actor))
  -> event
  -> GUI provider Scene ()
guiTriggerEventHandlers lens event = do
  triggerEventHandlers liftIO guiRunScriptActor lens event
  sceneRedraw

-- | A GUI action to force the redraw of all elements in a Scene, regardless of whether they lie
-- within the updated clip region, or whether they have requested a redraw. This operation will slow
-- down your application if used more often. Use 'sceneRedraw' to do a more efficient redraw.
forceSceneRedraw
  :: (HappletWindow provider render, Happlet2DGraphics render, ProvidesLogReporter provider)
  => GUI provider Scene ()
forceSceneRedraw =
  report DEBUG "forceSceneRedraw" >>
  use sceneRegistry >>= \ registry ->
  reactEventRegistryIO True
    (\ _halt roleRef -> do
        role0 <- lift (liftIO $ readIORef roleRef)
        let role = role0 &
              actionDraw %~ maybe id const (role0 ^. actionRedraw) &
              actionRedraw .~ Nothing
        lift $ onCanvas $ draw2D mempty (role ^. actionDraw)
        -- TODO ^ Skip if clipRect does not intersects with 'theBoundingBox' of 'actionDraw'?
        modify $ (<> (roleEventStats role))
        lift (liftIO $ writeIORef roleRef role)
        return (pure ())
    )
    registry mempty >>=
  assign sceneStats

-- | Redraw all elements that have changed. Each element is erased (by redrawing all elements below
-- it that intersect with it's bounding box), and then redrawn.
sceneRedraw
  :: (HappletWindow provider render, ProvidesLogReporter provider, Happlet2DGraphics render)
  => GUI provider Scene ()
sceneRedraw = do
  report DEBUG "sceneRedraw"
  registry <- use sceneRegistry
  -- first scan the registry for 'Actor's that need to be erased
  eraseRegion <- canonicalize2DShape . uncurry rect2DUnion <$>
    reactEventRegistryIO True
    (\ _halt roleRef -> do
       role <- liftIO (readIORef roleRef)
       modify $ \ (stack, count) -> case role ^. actionRedraw of
         Nothing -> (stack, count)
         Just {} -> (theBoundingBox (role ^. actionDraw) : stack, seq count $! count + 1)
       return empty
    )
    registry
    ([], 0)
  -- now redraw
  unless (rect2DUnionNull eraseRegion) $
    reactEventRegistryIO True
    (\ _halt roleRef ->
      liftIO (readIORef roleRef) >>= \ role0 ->
      case role0 ^. actionRedraw of
        Nothing -> do
          lift $ onCanvas $ draw2D eraseRegion $ role0 ^. actionDraw
          return empty
        Just newDraw -> do
          lift $ onCanvas $ draw2D eraseRegion newDraw
          let role = role0 & actionDraw .~ newDraw & actionRedraw .~ Nothing
          liftIO (writeIORef roleRef role)
          modify $ (<> (roleEventStats role))
          return $ pure ()
    )
    registry
    mempty >>=
    assign sceneStats

-- | Like 'liftIO' but only works in a the 'GUI' monad for an 'Act' data structure.
actLiftIO :: (Act -> IO a) -> GUI provider Act a
actLiftIO = (get >>=) . (liftIO .)

-- | Use this function to initialize a new 'Act'. This function is of type 'Initialize' so it can
-- only be used at initialization time. The @'Script' 'Scene' ()@ function can be used to setup the
-- 'Actor's that will first be visible when the 'Scene' opens on screen.
--
-- __NOTE:__ that the @'Script' 'Scene' ()@ function is really only to allow you to install 'Actor's
-- into the 'Scene' using the 'actor' or 'actress' functions. You may install event handlers into
-- the 'Scene' using functions like 'onKeyboard', but these event handlers will not be used in a
-- situation where all other actors in the scene have not already captured and dispatched the events
-- received. So any event handlers you install during the initialize 'Script' evaluation should only
-- be the "last resort" event handlers that are only triggered when no other 'Actor's have responded
-- to the event.
newActHapplet
  :: ProvidesLogReporter provider
  => Script Scene ()
  -> Initialize provider (Happlet Act)
newActHapplet init = newHappletIO $ do
  let act st = do
        now <- getCurrentTime
        let stats = theSceneStats . theScriptScene $ st
        hPutStrLn stderr $ "newActHapplet:\n" <> show stats
        pure $ Act
          { theActCurrentScene     = (theScriptRole st){ theRoleModel = theScriptScene st }
          , theRightMouseState     = mouseState now
          , theLeftMouseState      = mouseState now
          , theCurrentDragItem     = Nothing
          }
  scene <- makeEmptyScene (const $ hPutStrLn stderr . Strict.unpack) 16
  let rs = role scene
  actor <- liftIO $ makeActorIO rs
  runScript (init >> delegateSceneEvents) scene actor >>= \ case
    (ActionFail err, _ ) -> error $ "app initializer failed: " ++ show err
    (ActionCancel  , st) -> act st
    (ActionHalt    , st) -> act st
    (ActionOK   () , st) -> act st

-- | Use this function with the 'attachWindow' function and the result of 'newActHapplet' to create
-- the OS window.
actWindow
  :: ( CanMouse provider, CanKeyboard provider, CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render, ProvidesLogReporter provider
     )
  => PixSize -> GUI provider Act ()
actWindow _initSize = resetEventHandlers

----------------------------------------------------------------------------------------------------

-- Event handler resets

actSceneStats :: ProvidesLogReporter provider => GUI provider Act ActorEventHandlerStats
actSceneStats = do
  role <- use actCurrentScene
  let scene = theRoleModel role
  return $ theSceneStats scene <> roleEventStats role

actResetMouseEvents
  :: ( CanAnimate provider, CanMouse provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     , ProvidesLogReporter provider
     )
  => ActorEventHandlerStats -> GUI provider Act ()
actResetMouseEvents stats =
  let has f =
        maybe 0 f (countActionMouseRight stats) > 0 ||
        maybe 0 f (countActionMouseLeft  stats) > 0
  in
  let react which = mouseSignals which actMouseHandler in
  if countActionMouseOver stats > 0
  then report DEBUG "actResetMouseSignals MouseAll" >> react MouseAll
  else if has countActionMouseDrag
  then report DEBUG "actResetMouseSignals MouseDrag" >> react MouseDrag
  else if has countActionMouseDown || has countActionMouseClick || has countActionMouseDouble
  then report DEBUG "actResetMouseSignals MouseButton" >> react MouseButton
  else report DEBUG "actResetMouseSignals MouseAll cancel" >> (mouseSignals MouseAll $ const cancel)

actResetKeyboardEvents
  :: (CanKeyboard provider, ProvidesLogReporter provider)
  => GUI provider Scene ()
actResetKeyboardEvents = do
  keyboard <- maybe False (const True) <$> gets theSceneFocus
  report DEBUG ("actResetKeyboardEvents: " <> Strict.pack (show keyboard))
  keyboardEvents $ if keyboard then sceneKeyboardHandler else const cancel

actResetAnimationEvents
  :: ( CanAnimate provider, HappletWindow provider render
     , Managed provider, Happlet2DGraphics render
     , ProvidesLogReporter provider
     )
  => ActorEventHandlerStats -> GUI provider Act ()
actResetAnimationEvents stats = do
  report DEBUG "actResetAnimationEvents"
  stepFrameEvents $
    if countActionAnimation stats > 0 then actAnimationHandler else const cancel

resetEventHandlers
  :: ( CanMouse provider, CanKeyboard provider, CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     , ProvidesLogReporter provider
     )
  => GUI provider Act ()
resetEventHandlers = do
  onScene forceSceneRedraw -- This also retabluates the event hanlder statistics.
  stats <- actSceneStats
  report DEBUG $ Strict.pack $ "resetEventHandlers:\n" <> (show stats)
  newSize <- onCanvas getViewSize
  onScene $ sceneGlobalBounds %= (rect2DHead .~ newSize)
  actResetMouseEvents stats
  onScene actResetKeyboardEvents
  actResetAnimationEvents stats

----------------------------------------------------------------------------------------------------

-- Keyboard handler

-- | Force a 'Keyboard' event to occur in the current 'Act'.
sceneKeyboardHandler
  :: ProvidesLogReporter provider
  => Keyboard -> GUI provider Scene ()
sceneKeyboardHandler evt = case evt of
  Keyboard True _ _ -> run evt
  RawKey   True _ _ -> run evt
  _                 -> return ()
  where
  run evt =
    report DEBUG "sceneKeyboardHandler" >>
    use sceneFocus >>= \ case
      Nothing                -> return ()
      Just actor@(Actor ref) ->
        liftIO (readIORef ref) >>= \ role ->
        case theActionKeyboard role of
          Nothing     -> return ()
          Just script -> do
            let unfocus = sceneFocus .= Nothing
            guiRunScriptActor (runEventAction script evt) actor >>= \ case
              ActionOK ()    -> return ()
              ActionHalt     -> empty
              ActionCancel   -> unfocus >> cancel
              ActionFail msg -> unfocus >> throwError msg

----------------------------------------------------------------------------------------------------

-- Animation handler

-- | Force an animation step event to occur in the current 'Act'.
actAnimationHandler
  :: ( HappletWindow provider render, Managed provider, Happlet2DGraphics render
     , ProvidesLogReporter provider
     )
  => UTCTime -> GUI provider Act ()
actAnimationHandler t0 = do
  -- If there is an animation handler in effect, mouse actions are stored in 'actNextMouseAction' so
  -- that they may be delayed until the next animation frame event, to ensure mouse events are
  -- synchronized with animation frame events. The mouse handler MUST be executed first so that the
  -- UI feels more responsive, if mouse were executed after animation events, it would feel like the
  -- mouse event was delayed until after the frame step, so clicking on moving objects that are no
  -- longer under the mouse will feel to an end user like the mouse click is so slow it didn't hit
  -- the target in time.
  report DEBUG (Strict.pack $ "actAnimationHandler " <> show t0)
  actActualMouseHandler
  onScene $ guiTriggerEventHandlers actionAnimation t0

----------------------------------------------------------------------------------------------------

data MouseState
  = MouseState
    { theMouseStateTime     :: !UTCTime
    , theMouseStatePrevious :: !(Maybe MouseSignal)
    , theMouseStateSignal   :: !(Maybe MouseSignal)
      -- ^ Used for timing mouse reactions with animations.
    }
  deriving Eq

-- | The empty 'MouseState'
mouseState :: UTCTime -> MouseState
mouseState t0 =
  MouseState
  { theMouseStateTime     = t0
  , theMouseStatePrevious = Nothing
  , theMouseStateSignal   = Nothing
  }

mouseStateTime :: Lens' MouseState UTCTime
mouseStateTime = lens theMouseStateTime $ \ a b -> a{ theMouseStateTime = b }

mouseStateSignal :: Lens' MouseState (Maybe MouseSignal)
mouseStateSignal = lens theMouseStateSignal $ \ a b -> a{ theMouseStateSignal = b }

mouseStatePrevious :: Lens' MouseState (Maybe MouseSignal)
mouseStatePrevious = lens theMouseStateSignal $ \ a b -> a{ theMouseStateSignal = b }

-- | The 'actMouseHandler' has some pretty complex logic in order to make sure the mouse user
-- experience is very consistent across all apps built with the "Happlets.Actor" API.
--
-- Left clicks are de-bounced and timed so that single-click and double-click events can be decoded
-- from the click stream and translated into calls to 'sceneClick' and 'sceneDoubleClick'.
--
-- All other mouse actions are checked whether they are button-down or button-up events, and if they
-- are "button-down" (leading edge triggered), the mouse event is sent as it is to the 'actClick'
-- function for all 'Actor's in the 'Scene'.
actMouseHandler
  :: ( CanAnimate provider, Managed provider
     , HappletWindow provider render, Happlet2DGraphics render
     , ProvidesLogReporter provider
     )
  => MouseSignal -> GUI provider Act ()
actMouseHandler new@(MouseSignal _ pressed mods signalButton coord) = case signalButton of
  MotionOnly | not pressed -> onScene $ sceneMouseOver $
    Mouse2D
    { theMouse2DPosition = coord
    , theMouse2DModifiers = mods
    }
  LeftClick  -> debounce actLeftMouseState
  RightClick -> debounce actRightMouseState
  _ -> report DEBUG $ Strict.pack $ "ignored mouse signal (" <> show new <> ")"
  where
    debounce buttonLens = do
      -- TODO: certain constant values have been hard-coded into this function, like the
      -- double-click distance, and the minimum time required to elapse between events for the event
      -- to not be considered a "bounce". These hard-coded values should be taken from a global
      -- configuration variable.
      let minDelayBetweenEvents = 1/16
      present <- liftIO getCurrentTime
      past    <- use (cloneLens buttonLens . mouseStateTime)
      old     <- use (cloneLens buttonLens . mouseStateSignal)
      if maybe False (similarMouseSignals new) old &&
         diffUTCTime present past < minDelayBetweenEvents
        then do
          -- If the time difference between button-down and button-up signals are too small, the
          -- event is ignored, the latest event is recorded, overwriting the previously recorded
          -- event.
          report DEBUG $ Strict.pack $ "actMouseHandler: debounce (" <> show new <> ")"
          cloneLens buttonLens . mouseStateSignal .= Just new
        else do
          -- Here we set the mouse signal to be processed and pass control over toe
          -- 'actActualMouseHandler', unless there is an animation handler, in which case we do
          -- nothing and let the animation handler call 'actActualMouseHandler'.
          use (cloneLens buttonLens . mouseStateSignal) >>=
            assign (cloneLens buttonLens . mouseStatePrevious)
          cloneLens buttonLens . mouseStateSignal .= Just new
          cloneLens buttonLens . mouseStateTime   .= present
          stats <- actSceneStats
          if countActionAnimation stats <= 0 then actActualMouseHandler else
            report DEBUG $ Strict.pack $ "actMouseHandler: defer event " <> show new

-- Mouse events that can happen:
-- 1. First down -> set latest event
-- 2. Anomalous close before time-in -> push latest to previous, ignore all but latest
-- 3. Anomalous close after time-in -> ignore any but mouse up, an up generates click + push to previous
-- 4. Anomalous far before time-in -> if down, clear prior state, set new latest event
-- 5. Second down close after time-in -> update state, set latest event
-- 6. Second down far after time-in -> set state to drag event

-- | This is the function that actually executes the mouse action. The mouse action is taken from
-- the 'Act' state field 'theNextMouseAction'.
actActualMouseHandler
  :: ( HappletWindow provider render, Managed provider, Happlet2DGraphics render
     , ProvidesLogReporter provider
     )
  => GUI provider Act ()
actActualMouseHandler = stepFSA LeftMouseButton >> stepFSA RightMouseButton where
  stepFSA button = do
    let dragThreshold = 8
    let click2Threshold = 8
    -- TODO: certain constant values have been hard-coded into this function, like the
    -- double-click distance, and the minimum time required to elapse between events for the event
    -- to not be considered a "bounce". These hard-coded values should be taken from a global
    -- configuration variable.
    let buttonLens = actMouseButtonLens button :: ALens' Act MouseState
    let getData (MouseSignal _ _ mod _ coord) = Mouse2D
          { theMouse2DPosition = coord
          , theMouse2DModifiers = mod
          }
    let isPressed (MouseSignal _ pressed _ _ _) = pressed
    let clearSignals = cloneLens buttonLens %=
          (mouseStateSignal .~ Nothing) .
          (mouseStatePrevious .~ Nothing)
    st <- use (cloneLens buttonLens)
    case st ^. mouseStateSignal of
      Nothing -> case st ^. mouseStatePrevious of
        -- no previous signal, this is the first recent event
        Nothing -> return ()
          -- No signals at all, this function does nothing. This makes it safe to call at every step
          -- of an animation handler.
        Just signal1 ->
          if isPressed signal1 then
            onScene $ sceneMouseDown button $ getData signal1
          else
            return () -- Ignore isolated mouse up events.
      Just signal1 ->
        -- A previous signal exists. This is a more complex event dispatch.
        case st ^. mouseStateSignal of
          Nothing -> do
            clearSignals
            report DEBUG $ Strict.pack $
              "ignored mouse dispatch, mouseStateSignal is not set for " <> show button
          Just signal2 ->
            if isPressed signal1 then
              if isPressed signal2 then do
                -- Button depressed for 2 singals in a row means a drag event occurred.
                onScene $ sceneMouseDrag button $ Just $ getData signal2
              else if mouseSignalDistance signal1 signal2 >= dragThreshold then do
                -- Button down then up but distance between is greater than drag threshold means a
                -- drag occurred but started and completed very quickly.
                onScene $ sceneMouseDrag button $ Just $ getData signal2
                onScene $ sceneMouseDrag button Nothing
                clearSignals
              else do
                -- Button down then up, but within a distance less than the drag threshold means a
                -- mouse click occurred.
                onScene $ sceneMouseClick button $ getData signal2
                clearSignals
            else -- signal1 is not pressed
              if isPressed signal2 then
                if mouseSignalDistance signal1 signal2 < click2Threshold then do
                  onScene $ sceneMouseDoubleClick button $ getData signal2
                  clearSignals
                else
                  onScene $ sceneMouseDown button$ getData signal2
              else do
                clearSignals
                report DEBUG $ Strict.pack $
                  "ignored double-mouse up event on " <> show button

-- | Force a 'MouseSignal'-over event to occur in the current 'Act'.
sceneMouseOver
  :: ( HappletWindow provider render, Managed provider, Happlet2DGraphics render
     , ProvidesLogReporter provider
     )
  => PixelMouse -> GUI provider Scene ()
sceneMouseOver = guiTriggerEventHandlers actionMouseOver

-- | Force a 'Mouse' context menu button click event to occur in the current 'Act'.
sceneMouseDown
  :: (HappletWindow provider render, Happlet2DGraphics render, ProvidesLogReporter provider)
  => MouseButton -> PixelMouse -> GUI provider Scene ()
sceneMouseDown button event = do
  report DEBUG "sceneMouseDown"
  guiTriggerEventHandlers (actionMouseDown button) event

-- | Force a 'Mouse' context menu button click event to occur in the current 'Act'.
sceneMouseClick
  :: (HappletWindow provider render, Happlet2DGraphics render, ProvidesLogReporter provider)
  => MouseButton -> PixelMouse -> GUI provider Scene ()
sceneMouseClick button event = do
  report DEBUG "sceneMouseClick"
  guiTriggerEventHandlers (actionMouseClick button) event

-- | Force a 'Mouse' action button double click event to occur in the current 'Act'.
sceneMouseDoubleClick
  :: (HappletWindow provider render, Happlet2DGraphics render, ProvidesLogReporter provider)
  => MouseButton -> PixelMouse -> GUI provider Scene ()
sceneMouseDoubleClick button event = do
  report DEBUG "sceneMouseDoubleClick"
  guiTriggerEventHandlers (actionMouseDouble button) event

-- | Force a 'MouseSignal' drag event to occur in the current 'Act'.
sceneMouseDrag
  :: ( HappletWindow provider render, Managed provider, Happlet2DGraphics render
     , ProvidesLogReporter provider
     )
  => MouseButton -> Maybe PixelMouse -> GUI provider Scene ()
sceneMouseDrag button event = do
  report DEBUG "sceneMouseDrag"
  guiTriggerEventHandlers (actionMouseDrag button) event
